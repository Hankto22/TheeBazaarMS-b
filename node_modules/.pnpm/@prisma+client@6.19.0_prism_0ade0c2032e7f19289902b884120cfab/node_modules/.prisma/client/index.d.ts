
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model WashService
 * 
 */
export type WashService = $Result.DefaultSelection<Prisma.$WashServicePayload>
/**
 * Model WashTransaction
 * 
 */
export type WashTransaction = $Result.DefaultSelection<Prisma.$WashTransactionPayload>
/**
 * Model PromoCode
 * 
 */
export type PromoCode = $Result.DefaultSelection<Prisma.$PromoCodePayload>
/**
 * Model InventoryItem
 * 
 */
export type InventoryItem = $Result.DefaultSelection<Prisma.$InventoryItemPayload>
/**
 * Model InventoryUsage
 * 
 */
export type InventoryUsage = $Result.DefaultSelection<Prisma.$InventoryUsagePayload>
/**
 * Model Staff
 * 
 */
export type Staff = $Result.DefaultSelection<Prisma.$StaffPayload>
/**
 * Model StaffShift
 * 
 */
export type StaffShift = $Result.DefaultSelection<Prisma.$StaffShiftPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model BusinessSettings
 * 
 */
export type BusinessSettings = $Result.DefaultSelection<Prisma.$BusinessSettingsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Customers
 * const customers = await prisma.customer.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Customers
   * const customers = await prisma.customer.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.washService`: Exposes CRUD operations for the **WashService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WashServices
    * const washServices = await prisma.washService.findMany()
    * ```
    */
  get washService(): Prisma.WashServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.washTransaction`: Exposes CRUD operations for the **WashTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WashTransactions
    * const washTransactions = await prisma.washTransaction.findMany()
    * ```
    */
  get washTransaction(): Prisma.WashTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promoCode`: Exposes CRUD operations for the **PromoCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromoCodes
    * const promoCodes = await prisma.promoCode.findMany()
    * ```
    */
  get promoCode(): Prisma.PromoCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryItem`: Exposes CRUD operations for the **InventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryItems
    * const inventoryItems = await prisma.inventoryItem.findMany()
    * ```
    */
  get inventoryItem(): Prisma.InventoryItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryUsage`: Exposes CRUD operations for the **InventoryUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryUsages
    * const inventoryUsages = await prisma.inventoryUsage.findMany()
    * ```
    */
  get inventoryUsage(): Prisma.InventoryUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staff`: Exposes CRUD operations for the **Staff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Staff
    * const staff = await prisma.staff.findMany()
    * ```
    */
  get staff(): Prisma.StaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staffShift`: Exposes CRUD operations for the **StaffShift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaffShifts
    * const staffShifts = await prisma.staffShift.findMany()
    * ```
    */
  get staffShift(): Prisma.StaffShiftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.businessSettings`: Exposes CRUD operations for the **BusinessSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessSettings
    * const businessSettings = await prisma.businessSettings.findMany()
    * ```
    */
  get businessSettings(): Prisma.BusinessSettingsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Customer: 'Customer',
    WashService: 'WashService',
    WashTransaction: 'WashTransaction',
    PromoCode: 'PromoCode',
    InventoryItem: 'InventoryItem',
    InventoryUsage: 'InventoryUsage',
    Staff: 'Staff',
    StaffShift: 'StaffShift',
    AuditLog: 'AuditLog',
    BusinessSettings: 'BusinessSettings'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "customer" | "washService" | "washTransaction" | "promoCode" | "inventoryItem" | "inventoryUsage" | "staff" | "staffShift" | "auditLog" | "businessSettings"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      WashService: {
        payload: Prisma.$WashServicePayload<ExtArgs>
        fields: Prisma.WashServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WashServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WashServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashServicePayload>
          }
          findFirst: {
            args: Prisma.WashServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WashServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashServicePayload>
          }
          findMany: {
            args: Prisma.WashServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashServicePayload>[]
          }
          create: {
            args: Prisma.WashServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashServicePayload>
          }
          createMany: {
            args: Prisma.WashServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WashServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashServicePayload>[]
          }
          delete: {
            args: Prisma.WashServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashServicePayload>
          }
          update: {
            args: Prisma.WashServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashServicePayload>
          }
          deleteMany: {
            args: Prisma.WashServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WashServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WashServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashServicePayload>[]
          }
          upsert: {
            args: Prisma.WashServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashServicePayload>
          }
          aggregate: {
            args: Prisma.WashServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWashService>
          }
          groupBy: {
            args: Prisma.WashServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WashServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WashServiceCountArgs<ExtArgs>
            result: $Utils.Optional<WashServiceCountAggregateOutputType> | number
          }
        }
      }
      WashTransaction: {
        payload: Prisma.$WashTransactionPayload<ExtArgs>
        fields: Prisma.WashTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WashTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WashTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashTransactionPayload>
          }
          findFirst: {
            args: Prisma.WashTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WashTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashTransactionPayload>
          }
          findMany: {
            args: Prisma.WashTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashTransactionPayload>[]
          }
          create: {
            args: Prisma.WashTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashTransactionPayload>
          }
          createMany: {
            args: Prisma.WashTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WashTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashTransactionPayload>[]
          }
          delete: {
            args: Prisma.WashTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashTransactionPayload>
          }
          update: {
            args: Prisma.WashTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashTransactionPayload>
          }
          deleteMany: {
            args: Prisma.WashTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WashTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WashTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashTransactionPayload>[]
          }
          upsert: {
            args: Prisma.WashTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WashTransactionPayload>
          }
          aggregate: {
            args: Prisma.WashTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWashTransaction>
          }
          groupBy: {
            args: Prisma.WashTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WashTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WashTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<WashTransactionCountAggregateOutputType> | number
          }
        }
      }
      PromoCode: {
        payload: Prisma.$PromoCodePayload<ExtArgs>
        fields: Prisma.PromoCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromoCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromoCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          findFirst: {
            args: Prisma.PromoCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromoCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          findMany: {
            args: Prisma.PromoCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          create: {
            args: Prisma.PromoCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          createMany: {
            args: Prisma.PromoCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromoCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          delete: {
            args: Prisma.PromoCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          update: {
            args: Prisma.PromoCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          deleteMany: {
            args: Prisma.PromoCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromoCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromoCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          upsert: {
            args: Prisma.PromoCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          aggregate: {
            args: Prisma.PromoCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromoCode>
          }
          groupBy: {
            args: Prisma.PromoCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromoCodeCountArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeCountAggregateOutputType> | number
          }
        }
      }
      InventoryItem: {
        payload: Prisma.$InventoryItemPayload<ExtArgs>
        fields: Prisma.InventoryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findFirst: {
            args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findMany: {
            args: Prisma.InventoryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          create: {
            args: Prisma.InventoryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          createMany: {
            args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          delete: {
            args: Prisma.InventoryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          update: {
            args: Prisma.InventoryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          upsert: {
            args: Prisma.InventoryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          aggregate: {
            args: Prisma.InventoryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryItem>
          }
          groupBy: {
            args: Prisma.InventoryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryItemCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemCountAggregateOutputType> | number
          }
        }
      }
      InventoryUsage: {
        payload: Prisma.$InventoryUsagePayload<ExtArgs>
        fields: Prisma.InventoryUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUsagePayload>
          }
          findFirst: {
            args: Prisma.InventoryUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUsagePayload>
          }
          findMany: {
            args: Prisma.InventoryUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUsagePayload>[]
          }
          create: {
            args: Prisma.InventoryUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUsagePayload>
          }
          createMany: {
            args: Prisma.InventoryUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUsagePayload>[]
          }
          delete: {
            args: Prisma.InventoryUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUsagePayload>
          }
          update: {
            args: Prisma.InventoryUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUsagePayload>
          }
          deleteMany: {
            args: Prisma.InventoryUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUsagePayload>[]
          }
          upsert: {
            args: Prisma.InventoryUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryUsagePayload>
          }
          aggregate: {
            args: Prisma.InventoryUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryUsage>
          }
          groupBy: {
            args: Prisma.InventoryUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryUsageCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryUsageCountAggregateOutputType> | number
          }
        }
      }
      Staff: {
        payload: Prisma.$StaffPayload<ExtArgs>
        fields: Prisma.StaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          findFirst: {
            args: Prisma.StaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          findMany: {
            args: Prisma.StaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          create: {
            args: Prisma.StaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          createMany: {
            args: Prisma.StaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          delete: {
            args: Prisma.StaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          update: {
            args: Prisma.StaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          deleteMany: {
            args: Prisma.StaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          upsert: {
            args: Prisma.StaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          aggregate: {
            args: Prisma.StaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaff>
          }
          groupBy: {
            args: Prisma.StaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffCountArgs<ExtArgs>
            result: $Utils.Optional<StaffCountAggregateOutputType> | number
          }
        }
      }
      StaffShift: {
        payload: Prisma.$StaffShiftPayload<ExtArgs>
        fields: Prisma.StaffShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload>
          }
          findFirst: {
            args: Prisma.StaffShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload>
          }
          findMany: {
            args: Prisma.StaffShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload>[]
          }
          create: {
            args: Prisma.StaffShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload>
          }
          createMany: {
            args: Prisma.StaffShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffShiftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload>[]
          }
          delete: {
            args: Prisma.StaffShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload>
          }
          update: {
            args: Prisma.StaffShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload>
          }
          deleteMany: {
            args: Prisma.StaffShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StaffShiftUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload>[]
          }
          upsert: {
            args: Prisma.StaffShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffShiftPayload>
          }
          aggregate: {
            args: Prisma.StaffShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaffShift>
          }
          groupBy: {
            args: Prisma.StaffShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffShiftCountArgs<ExtArgs>
            result: $Utils.Optional<StaffShiftCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      BusinessSettings: {
        payload: Prisma.$BusinessSettingsPayload<ExtArgs>
        fields: Prisma.BusinessSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSettingsPayload>
          }
          findFirst: {
            args: Prisma.BusinessSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSettingsPayload>
          }
          findMany: {
            args: Prisma.BusinessSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSettingsPayload>[]
          }
          create: {
            args: Prisma.BusinessSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSettingsPayload>
          }
          createMany: {
            args: Prisma.BusinessSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSettingsPayload>[]
          }
          delete: {
            args: Prisma.BusinessSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSettingsPayload>
          }
          update: {
            args: Prisma.BusinessSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSettingsPayload>
          }
          deleteMany: {
            args: Prisma.BusinessSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BusinessSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSettingsPayload>[]
          }
          upsert: {
            args: Prisma.BusinessSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessSettingsPayload>
          }
          aggregate: {
            args: Prisma.BusinessSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessSettings>
          }
          groupBy: {
            args: Prisma.BusinessSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessSettingsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    customer?: CustomerOmit
    washService?: WashServiceOmit
    washTransaction?: WashTransactionOmit
    promoCode?: PromoCodeOmit
    inventoryItem?: InventoryItemOmit
    inventoryUsage?: InventoryUsageOmit
    staff?: StaffOmit
    staffShift?: StaffShiftOmit
    auditLog?: AuditLogOmit
    businessSettings?: BusinessSettingsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    transactions: number
    referrals: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | CustomerCountOutputTypeCountTransactionsArgs
    referrals?: boolean | CustomerCountOutputTypeCountReferralsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WashTransactionWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }


  /**
   * Count Type WashServiceCountOutputType
   */

  export type WashServiceCountOutputType = {
    transactions: number
  }

  export type WashServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | WashServiceCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * WashServiceCountOutputType without action
   */
  export type WashServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashServiceCountOutputType
     */
    select?: WashServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WashServiceCountOutputType without action
   */
  export type WashServiceCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WashTransactionWhereInput
  }


  /**
   * Count Type PromoCodeCountOutputType
   */

  export type PromoCodeCountOutputType = {
    transactions: number
  }

  export type PromoCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | PromoCodeCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeCountOutputType
     */
    select?: PromoCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WashTransactionWhereInput
  }


  /**
   * Count Type InventoryItemCountOutputType
   */

  export type InventoryItemCountOutputType = {
    usages: number
  }

  export type InventoryItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usages?: boolean | InventoryItemCountOutputTypeCountUsagesArgs
  }

  // Custom InputTypes
  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItemCountOutputType
     */
    select?: InventoryItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryUsageWhereInput
  }


  /**
   * Count Type StaffCountOutputType
   */

  export type StaffCountOutputType = {
    shifts: number
    audits: number
  }

  export type StaffCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shifts?: boolean | StaffCountOutputTypeCountShiftsArgs
    audits?: boolean | StaffCountOutputTypeCountAuditsArgs
  }

  // Custom InputTypes
  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffCountOutputType
     */
    select?: StaffCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffShiftWhereInput
  }

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    loyaltyPoints: number | null
  }

  export type CustomerSumAggregateOutputType = {
    loyaltyPoints: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    email: string | null
    loyaltyPoints: number | null
    loyaltyTier: string | null
    referralCode: string | null
    referredBy: string | null
    createdAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    email: string | null
    loyaltyPoints: number | null
    loyaltyTier: string | null
    referralCode: string | null
    referredBy: string | null
    createdAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    email: number
    loyaltyPoints: number
    loyaltyTier: number
    referralCode: number
    referredBy: number
    preferences: number
    createdAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    loyaltyPoints?: true
  }

  export type CustomerSumAggregateInputType = {
    loyaltyPoints?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    loyaltyPoints?: true
    loyaltyTier?: true
    referralCode?: true
    referredBy?: true
    createdAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    loyaltyPoints?: true
    loyaltyTier?: true
    referralCode?: true
    referredBy?: true
    createdAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    loyaltyPoints?: true
    loyaltyTier?: true
    referralCode?: true
    referredBy?: true
    preferences?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    name: string
    phone: string | null
    email: string | null
    loyaltyPoints: number
    loyaltyTier: string
    referralCode: string | null
    referredBy: string | null
    preferences: JsonValue | null
    createdAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    loyaltyPoints?: boolean
    loyaltyTier?: boolean
    referralCode?: boolean
    referredBy?: boolean
    preferences?: boolean
    createdAt?: boolean
    transactions?: boolean | Customer$transactionsArgs<ExtArgs>
    referrals?: boolean | Customer$referralsArgs<ExtArgs>
    referrer?: boolean | Customer$referrerArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    loyaltyPoints?: boolean
    loyaltyTier?: boolean
    referralCode?: boolean
    referredBy?: boolean
    preferences?: boolean
    createdAt?: boolean
    referrer?: boolean | Customer$referrerArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    loyaltyPoints?: boolean
    loyaltyTier?: boolean
    referralCode?: boolean
    referredBy?: boolean
    preferences?: boolean
    createdAt?: boolean
    referrer?: boolean | Customer$referrerArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    loyaltyPoints?: boolean
    loyaltyTier?: boolean
    referralCode?: boolean
    referredBy?: boolean
    preferences?: boolean
    createdAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "email" | "loyaltyPoints" | "loyaltyTier" | "referralCode" | "referredBy" | "preferences" | "createdAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | Customer$transactionsArgs<ExtArgs>
    referrals?: boolean | Customer$referralsArgs<ExtArgs>
    referrer?: boolean | Customer$referrerArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | Customer$referrerArgs<ExtArgs>
  }
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | Customer$referrerArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      transactions: Prisma.$WashTransactionPayload<ExtArgs>[]
      referrals: Prisma.$CustomerPayload<ExtArgs>[]
      referrer: Prisma.$CustomerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      phone: string | null
      email: string | null
      loyaltyPoints: number
      loyaltyTier: string
      referralCode: string | null
      referredBy: string | null
      preferences: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends Customer$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WashTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referrals<T extends Customer$referralsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referrer<T extends Customer$referrerArgs<ExtArgs> = {}>(args?: Subset<T, Customer$referrerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly loyaltyPoints: FieldRef<"Customer", 'Int'>
    readonly loyaltyTier: FieldRef<"Customer", 'String'>
    readonly referralCode: FieldRef<"Customer", 'String'>
    readonly referredBy: FieldRef<"Customer", 'String'>
    readonly preferences: FieldRef<"Customer", 'Json'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.transactions
   */
  export type Customer$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashTransaction
     */
    select?: WashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashTransaction
     */
    omit?: WashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashTransactionInclude<ExtArgs> | null
    where?: WashTransactionWhereInput
    orderBy?: WashTransactionOrderByWithRelationInput | WashTransactionOrderByWithRelationInput[]
    cursor?: WashTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WashTransactionScalarFieldEnum | WashTransactionScalarFieldEnum[]
  }

  /**
   * Customer.referrals
   */
  export type Customer$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer.referrer
   */
  export type Customer$referrerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model WashService
   */

  export type AggregateWashService = {
    _count: WashServiceCountAggregateOutputType | null
    _avg: WashServiceAvgAggregateOutputType | null
    _sum: WashServiceSumAggregateOutputType | null
    _min: WashServiceMinAggregateOutputType | null
    _max: WashServiceMaxAggregateOutputType | null
  }

  export type WashServiceAvgAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type WashServiceSumAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type WashServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    duration: number | null
    createdAt: Date | null
  }

  export type WashServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    duration: number | null
    createdAt: Date | null
  }

  export type WashServiceCountAggregateOutputType = {
    id: number
    name: number
    price: number
    duration: number
    createdAt: number
    _all: number
  }


  export type WashServiceAvgAggregateInputType = {
    price?: true
    duration?: true
  }

  export type WashServiceSumAggregateInputType = {
    price?: true
    duration?: true
  }

  export type WashServiceMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration?: true
    createdAt?: true
  }

  export type WashServiceMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration?: true
    createdAt?: true
  }

  export type WashServiceCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration?: true
    createdAt?: true
    _all?: true
  }

  export type WashServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WashService to aggregate.
     */
    where?: WashServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WashServices to fetch.
     */
    orderBy?: WashServiceOrderByWithRelationInput | WashServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WashServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WashServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WashServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WashServices
    **/
    _count?: true | WashServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WashServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WashServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WashServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WashServiceMaxAggregateInputType
  }

  export type GetWashServiceAggregateType<T extends WashServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateWashService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWashService[P]>
      : GetScalarType<T[P], AggregateWashService[P]>
  }




  export type WashServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WashServiceWhereInput
    orderBy?: WashServiceOrderByWithAggregationInput | WashServiceOrderByWithAggregationInput[]
    by: WashServiceScalarFieldEnum[] | WashServiceScalarFieldEnum
    having?: WashServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WashServiceCountAggregateInputType | true
    _avg?: WashServiceAvgAggregateInputType
    _sum?: WashServiceSumAggregateInputType
    _min?: WashServiceMinAggregateInputType
    _max?: WashServiceMaxAggregateInputType
  }

  export type WashServiceGroupByOutputType = {
    id: string
    name: string
    price: number
    duration: number
    createdAt: Date
    _count: WashServiceCountAggregateOutputType | null
    _avg: WashServiceAvgAggregateOutputType | null
    _sum: WashServiceSumAggregateOutputType | null
    _min: WashServiceMinAggregateOutputType | null
    _max: WashServiceMaxAggregateOutputType | null
  }

  type GetWashServiceGroupByPayload<T extends WashServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WashServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WashServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WashServiceGroupByOutputType[P]>
            : GetScalarType<T[P], WashServiceGroupByOutputType[P]>
        }
      >
    >


  export type WashServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    createdAt?: boolean
    transactions?: boolean | WashService$transactionsArgs<ExtArgs>
    _count?: boolean | WashServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["washService"]>

  export type WashServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["washService"]>

  export type WashServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["washService"]>

  export type WashServiceSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    createdAt?: boolean
  }

  export type WashServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "price" | "duration" | "createdAt", ExtArgs["result"]["washService"]>
  export type WashServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | WashService$transactionsArgs<ExtArgs>
    _count?: boolean | WashServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WashServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WashServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WashServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WashService"
    objects: {
      transactions: Prisma.$WashTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      price: number
      duration: number
      createdAt: Date
    }, ExtArgs["result"]["washService"]>
    composites: {}
  }

  type WashServiceGetPayload<S extends boolean | null | undefined | WashServiceDefaultArgs> = $Result.GetResult<Prisma.$WashServicePayload, S>

  type WashServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WashServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WashServiceCountAggregateInputType | true
    }

  export interface WashServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WashService'], meta: { name: 'WashService' } }
    /**
     * Find zero or one WashService that matches the filter.
     * @param {WashServiceFindUniqueArgs} args - Arguments to find a WashService
     * @example
     * // Get one WashService
     * const washService = await prisma.washService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WashServiceFindUniqueArgs>(args: SelectSubset<T, WashServiceFindUniqueArgs<ExtArgs>>): Prisma__WashServiceClient<$Result.GetResult<Prisma.$WashServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WashService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WashServiceFindUniqueOrThrowArgs} args - Arguments to find a WashService
     * @example
     * // Get one WashService
     * const washService = await prisma.washService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WashServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, WashServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WashServiceClient<$Result.GetResult<Prisma.$WashServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WashService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashServiceFindFirstArgs} args - Arguments to find a WashService
     * @example
     * // Get one WashService
     * const washService = await prisma.washService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WashServiceFindFirstArgs>(args?: SelectSubset<T, WashServiceFindFirstArgs<ExtArgs>>): Prisma__WashServiceClient<$Result.GetResult<Prisma.$WashServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WashService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashServiceFindFirstOrThrowArgs} args - Arguments to find a WashService
     * @example
     * // Get one WashService
     * const washService = await prisma.washService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WashServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, WashServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WashServiceClient<$Result.GetResult<Prisma.$WashServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WashServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WashServices
     * const washServices = await prisma.washService.findMany()
     * 
     * // Get first 10 WashServices
     * const washServices = await prisma.washService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const washServiceWithIdOnly = await prisma.washService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WashServiceFindManyArgs>(args?: SelectSubset<T, WashServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WashServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WashService.
     * @param {WashServiceCreateArgs} args - Arguments to create a WashService.
     * @example
     * // Create one WashService
     * const WashService = await prisma.washService.create({
     *   data: {
     *     // ... data to create a WashService
     *   }
     * })
     * 
     */
    create<T extends WashServiceCreateArgs>(args: SelectSubset<T, WashServiceCreateArgs<ExtArgs>>): Prisma__WashServiceClient<$Result.GetResult<Prisma.$WashServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WashServices.
     * @param {WashServiceCreateManyArgs} args - Arguments to create many WashServices.
     * @example
     * // Create many WashServices
     * const washService = await prisma.washService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WashServiceCreateManyArgs>(args?: SelectSubset<T, WashServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WashServices and returns the data saved in the database.
     * @param {WashServiceCreateManyAndReturnArgs} args - Arguments to create many WashServices.
     * @example
     * // Create many WashServices
     * const washService = await prisma.washService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WashServices and only return the `id`
     * const washServiceWithIdOnly = await prisma.washService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WashServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, WashServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WashServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WashService.
     * @param {WashServiceDeleteArgs} args - Arguments to delete one WashService.
     * @example
     * // Delete one WashService
     * const WashService = await prisma.washService.delete({
     *   where: {
     *     // ... filter to delete one WashService
     *   }
     * })
     * 
     */
    delete<T extends WashServiceDeleteArgs>(args: SelectSubset<T, WashServiceDeleteArgs<ExtArgs>>): Prisma__WashServiceClient<$Result.GetResult<Prisma.$WashServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WashService.
     * @param {WashServiceUpdateArgs} args - Arguments to update one WashService.
     * @example
     * // Update one WashService
     * const washService = await prisma.washService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WashServiceUpdateArgs>(args: SelectSubset<T, WashServiceUpdateArgs<ExtArgs>>): Prisma__WashServiceClient<$Result.GetResult<Prisma.$WashServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WashServices.
     * @param {WashServiceDeleteManyArgs} args - Arguments to filter WashServices to delete.
     * @example
     * // Delete a few WashServices
     * const { count } = await prisma.washService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WashServiceDeleteManyArgs>(args?: SelectSubset<T, WashServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WashServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WashServices
     * const washService = await prisma.washService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WashServiceUpdateManyArgs>(args: SelectSubset<T, WashServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WashServices and returns the data updated in the database.
     * @param {WashServiceUpdateManyAndReturnArgs} args - Arguments to update many WashServices.
     * @example
     * // Update many WashServices
     * const washService = await prisma.washService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WashServices and only return the `id`
     * const washServiceWithIdOnly = await prisma.washService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WashServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, WashServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WashServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WashService.
     * @param {WashServiceUpsertArgs} args - Arguments to update or create a WashService.
     * @example
     * // Update or create a WashService
     * const washService = await prisma.washService.upsert({
     *   create: {
     *     // ... data to create a WashService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WashService we want to update
     *   }
     * })
     */
    upsert<T extends WashServiceUpsertArgs>(args: SelectSubset<T, WashServiceUpsertArgs<ExtArgs>>): Prisma__WashServiceClient<$Result.GetResult<Prisma.$WashServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WashServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashServiceCountArgs} args - Arguments to filter WashServices to count.
     * @example
     * // Count the number of WashServices
     * const count = await prisma.washService.count({
     *   where: {
     *     // ... the filter for the WashServices we want to count
     *   }
     * })
    **/
    count<T extends WashServiceCountArgs>(
      args?: Subset<T, WashServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WashServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WashService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WashServiceAggregateArgs>(args: Subset<T, WashServiceAggregateArgs>): Prisma.PrismaPromise<GetWashServiceAggregateType<T>>

    /**
     * Group by WashService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WashServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WashServiceGroupByArgs['orderBy'] }
        : { orderBy?: WashServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WashServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWashServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WashService model
   */
  readonly fields: WashServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WashService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WashServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends WashService$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, WashService$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WashTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WashService model
   */
  interface WashServiceFieldRefs {
    readonly id: FieldRef<"WashService", 'String'>
    readonly name: FieldRef<"WashService", 'String'>
    readonly price: FieldRef<"WashService", 'Float'>
    readonly duration: FieldRef<"WashService", 'Int'>
    readonly createdAt: FieldRef<"WashService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WashService findUnique
   */
  export type WashServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashService
     */
    select?: WashServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashService
     */
    omit?: WashServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashServiceInclude<ExtArgs> | null
    /**
     * Filter, which WashService to fetch.
     */
    where: WashServiceWhereUniqueInput
  }

  /**
   * WashService findUniqueOrThrow
   */
  export type WashServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashService
     */
    select?: WashServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashService
     */
    omit?: WashServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashServiceInclude<ExtArgs> | null
    /**
     * Filter, which WashService to fetch.
     */
    where: WashServiceWhereUniqueInput
  }

  /**
   * WashService findFirst
   */
  export type WashServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashService
     */
    select?: WashServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashService
     */
    omit?: WashServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashServiceInclude<ExtArgs> | null
    /**
     * Filter, which WashService to fetch.
     */
    where?: WashServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WashServices to fetch.
     */
    orderBy?: WashServiceOrderByWithRelationInput | WashServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WashServices.
     */
    cursor?: WashServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WashServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WashServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WashServices.
     */
    distinct?: WashServiceScalarFieldEnum | WashServiceScalarFieldEnum[]
  }

  /**
   * WashService findFirstOrThrow
   */
  export type WashServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashService
     */
    select?: WashServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashService
     */
    omit?: WashServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashServiceInclude<ExtArgs> | null
    /**
     * Filter, which WashService to fetch.
     */
    where?: WashServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WashServices to fetch.
     */
    orderBy?: WashServiceOrderByWithRelationInput | WashServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WashServices.
     */
    cursor?: WashServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WashServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WashServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WashServices.
     */
    distinct?: WashServiceScalarFieldEnum | WashServiceScalarFieldEnum[]
  }

  /**
   * WashService findMany
   */
  export type WashServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashService
     */
    select?: WashServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashService
     */
    omit?: WashServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashServiceInclude<ExtArgs> | null
    /**
     * Filter, which WashServices to fetch.
     */
    where?: WashServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WashServices to fetch.
     */
    orderBy?: WashServiceOrderByWithRelationInput | WashServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WashServices.
     */
    cursor?: WashServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WashServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WashServices.
     */
    skip?: number
    distinct?: WashServiceScalarFieldEnum | WashServiceScalarFieldEnum[]
  }

  /**
   * WashService create
   */
  export type WashServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashService
     */
    select?: WashServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashService
     */
    omit?: WashServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a WashService.
     */
    data: XOR<WashServiceCreateInput, WashServiceUncheckedCreateInput>
  }

  /**
   * WashService createMany
   */
  export type WashServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WashServices.
     */
    data: WashServiceCreateManyInput | WashServiceCreateManyInput[]
  }

  /**
   * WashService createManyAndReturn
   */
  export type WashServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashService
     */
    select?: WashServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WashService
     */
    omit?: WashServiceOmit<ExtArgs> | null
    /**
     * The data used to create many WashServices.
     */
    data: WashServiceCreateManyInput | WashServiceCreateManyInput[]
  }

  /**
   * WashService update
   */
  export type WashServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashService
     */
    select?: WashServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashService
     */
    omit?: WashServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a WashService.
     */
    data: XOR<WashServiceUpdateInput, WashServiceUncheckedUpdateInput>
    /**
     * Choose, which WashService to update.
     */
    where: WashServiceWhereUniqueInput
  }

  /**
   * WashService updateMany
   */
  export type WashServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WashServices.
     */
    data: XOR<WashServiceUpdateManyMutationInput, WashServiceUncheckedUpdateManyInput>
    /**
     * Filter which WashServices to update
     */
    where?: WashServiceWhereInput
    /**
     * Limit how many WashServices to update.
     */
    limit?: number
  }

  /**
   * WashService updateManyAndReturn
   */
  export type WashServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashService
     */
    select?: WashServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WashService
     */
    omit?: WashServiceOmit<ExtArgs> | null
    /**
     * The data used to update WashServices.
     */
    data: XOR<WashServiceUpdateManyMutationInput, WashServiceUncheckedUpdateManyInput>
    /**
     * Filter which WashServices to update
     */
    where?: WashServiceWhereInput
    /**
     * Limit how many WashServices to update.
     */
    limit?: number
  }

  /**
   * WashService upsert
   */
  export type WashServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashService
     */
    select?: WashServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashService
     */
    omit?: WashServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the WashService to update in case it exists.
     */
    where: WashServiceWhereUniqueInput
    /**
     * In case the WashService found by the `where` argument doesn't exist, create a new WashService with this data.
     */
    create: XOR<WashServiceCreateInput, WashServiceUncheckedCreateInput>
    /**
     * In case the WashService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WashServiceUpdateInput, WashServiceUncheckedUpdateInput>
  }

  /**
   * WashService delete
   */
  export type WashServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashService
     */
    select?: WashServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashService
     */
    omit?: WashServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashServiceInclude<ExtArgs> | null
    /**
     * Filter which WashService to delete.
     */
    where: WashServiceWhereUniqueInput
  }

  /**
   * WashService deleteMany
   */
  export type WashServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WashServices to delete
     */
    where?: WashServiceWhereInput
    /**
     * Limit how many WashServices to delete.
     */
    limit?: number
  }

  /**
   * WashService.transactions
   */
  export type WashService$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashTransaction
     */
    select?: WashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashTransaction
     */
    omit?: WashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashTransactionInclude<ExtArgs> | null
    where?: WashTransactionWhereInput
    orderBy?: WashTransactionOrderByWithRelationInput | WashTransactionOrderByWithRelationInput[]
    cursor?: WashTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WashTransactionScalarFieldEnum | WashTransactionScalarFieldEnum[]
  }

  /**
   * WashService without action
   */
  export type WashServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashService
     */
    select?: WashServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashService
     */
    omit?: WashServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashServiceInclude<ExtArgs> | null
  }


  /**
   * Model WashTransaction
   */

  export type AggregateWashTransaction = {
    _count: WashTransactionCountAggregateOutputType | null
    _avg: WashTransactionAvgAggregateOutputType | null
    _sum: WashTransactionSumAggregateOutputType | null
    _min: WashTransactionMinAggregateOutputType | null
    _max: WashTransactionMaxAggregateOutputType | null
  }

  export type WashTransactionAvgAggregateOutputType = {
    quantity: number | null
    total: number | null
    discount: number | null
  }

  export type WashTransactionSumAggregateOutputType = {
    quantity: number | null
    total: number | null
    discount: number | null
  }

  export type WashTransactionMinAggregateOutputType = {
    id: string | null
    serviceId: string | null
    customerId: string | null
    quantity: number | null
    total: number | null
    paymentMethod: string | null
    vehicleType: string | null
    discount: number | null
    promoCodeId: string | null
    receiptNumber: string | null
    createdAt: Date | null
  }

  export type WashTransactionMaxAggregateOutputType = {
    id: string | null
    serviceId: string | null
    customerId: string | null
    quantity: number | null
    total: number | null
    paymentMethod: string | null
    vehicleType: string | null
    discount: number | null
    promoCodeId: string | null
    receiptNumber: string | null
    createdAt: Date | null
  }

  export type WashTransactionCountAggregateOutputType = {
    id: number
    serviceId: number
    customerId: number
    quantity: number
    total: number
    paymentMethod: number
    vehicleType: number
    discount: number
    promoCodeId: number
    receiptNumber: number
    createdAt: number
    _all: number
  }


  export type WashTransactionAvgAggregateInputType = {
    quantity?: true
    total?: true
    discount?: true
  }

  export type WashTransactionSumAggregateInputType = {
    quantity?: true
    total?: true
    discount?: true
  }

  export type WashTransactionMinAggregateInputType = {
    id?: true
    serviceId?: true
    customerId?: true
    quantity?: true
    total?: true
    paymentMethod?: true
    vehicleType?: true
    discount?: true
    promoCodeId?: true
    receiptNumber?: true
    createdAt?: true
  }

  export type WashTransactionMaxAggregateInputType = {
    id?: true
    serviceId?: true
    customerId?: true
    quantity?: true
    total?: true
    paymentMethod?: true
    vehicleType?: true
    discount?: true
    promoCodeId?: true
    receiptNumber?: true
    createdAt?: true
  }

  export type WashTransactionCountAggregateInputType = {
    id?: true
    serviceId?: true
    customerId?: true
    quantity?: true
    total?: true
    paymentMethod?: true
    vehicleType?: true
    discount?: true
    promoCodeId?: true
    receiptNumber?: true
    createdAt?: true
    _all?: true
  }

  export type WashTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WashTransaction to aggregate.
     */
    where?: WashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WashTransactions to fetch.
     */
    orderBy?: WashTransactionOrderByWithRelationInput | WashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WashTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WashTransactions
    **/
    _count?: true | WashTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WashTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WashTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WashTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WashTransactionMaxAggregateInputType
  }

  export type GetWashTransactionAggregateType<T extends WashTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateWashTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWashTransaction[P]>
      : GetScalarType<T[P], AggregateWashTransaction[P]>
  }




  export type WashTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WashTransactionWhereInput
    orderBy?: WashTransactionOrderByWithAggregationInput | WashTransactionOrderByWithAggregationInput[]
    by: WashTransactionScalarFieldEnum[] | WashTransactionScalarFieldEnum
    having?: WashTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WashTransactionCountAggregateInputType | true
    _avg?: WashTransactionAvgAggregateInputType
    _sum?: WashTransactionSumAggregateInputType
    _min?: WashTransactionMinAggregateInputType
    _max?: WashTransactionMaxAggregateInputType
  }

  export type WashTransactionGroupByOutputType = {
    id: string
    serviceId: string
    customerId: string | null
    quantity: number
    total: number
    paymentMethod: string | null
    vehicleType: string | null
    discount: number | null
    promoCodeId: string | null
    receiptNumber: string | null
    createdAt: Date
    _count: WashTransactionCountAggregateOutputType | null
    _avg: WashTransactionAvgAggregateOutputType | null
    _sum: WashTransactionSumAggregateOutputType | null
    _min: WashTransactionMinAggregateOutputType | null
    _max: WashTransactionMaxAggregateOutputType | null
  }

  type GetWashTransactionGroupByPayload<T extends WashTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WashTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WashTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WashTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], WashTransactionGroupByOutputType[P]>
        }
      >
    >


  export type WashTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    customerId?: boolean
    quantity?: boolean
    total?: boolean
    paymentMethod?: boolean
    vehicleType?: boolean
    discount?: boolean
    promoCodeId?: boolean
    receiptNumber?: boolean
    createdAt?: boolean
    service?: boolean | WashServiceDefaultArgs<ExtArgs>
    customer?: boolean | WashTransaction$customerArgs<ExtArgs>
    promoCode?: boolean | WashTransaction$promoCodeArgs<ExtArgs>
  }, ExtArgs["result"]["washTransaction"]>

  export type WashTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    customerId?: boolean
    quantity?: boolean
    total?: boolean
    paymentMethod?: boolean
    vehicleType?: boolean
    discount?: boolean
    promoCodeId?: boolean
    receiptNumber?: boolean
    createdAt?: boolean
    service?: boolean | WashServiceDefaultArgs<ExtArgs>
    customer?: boolean | WashTransaction$customerArgs<ExtArgs>
    promoCode?: boolean | WashTransaction$promoCodeArgs<ExtArgs>
  }, ExtArgs["result"]["washTransaction"]>

  export type WashTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    customerId?: boolean
    quantity?: boolean
    total?: boolean
    paymentMethod?: boolean
    vehicleType?: boolean
    discount?: boolean
    promoCodeId?: boolean
    receiptNumber?: boolean
    createdAt?: boolean
    service?: boolean | WashServiceDefaultArgs<ExtArgs>
    customer?: boolean | WashTransaction$customerArgs<ExtArgs>
    promoCode?: boolean | WashTransaction$promoCodeArgs<ExtArgs>
  }, ExtArgs["result"]["washTransaction"]>

  export type WashTransactionSelectScalar = {
    id?: boolean
    serviceId?: boolean
    customerId?: boolean
    quantity?: boolean
    total?: boolean
    paymentMethod?: boolean
    vehicleType?: boolean
    discount?: boolean
    promoCodeId?: boolean
    receiptNumber?: boolean
    createdAt?: boolean
  }

  export type WashTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceId" | "customerId" | "quantity" | "total" | "paymentMethod" | "vehicleType" | "discount" | "promoCodeId" | "receiptNumber" | "createdAt", ExtArgs["result"]["washTransaction"]>
  export type WashTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | WashServiceDefaultArgs<ExtArgs>
    customer?: boolean | WashTransaction$customerArgs<ExtArgs>
    promoCode?: boolean | WashTransaction$promoCodeArgs<ExtArgs>
  }
  export type WashTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | WashServiceDefaultArgs<ExtArgs>
    customer?: boolean | WashTransaction$customerArgs<ExtArgs>
    promoCode?: boolean | WashTransaction$promoCodeArgs<ExtArgs>
  }
  export type WashTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | WashServiceDefaultArgs<ExtArgs>
    customer?: boolean | WashTransaction$customerArgs<ExtArgs>
    promoCode?: boolean | WashTransaction$promoCodeArgs<ExtArgs>
  }

  export type $WashTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WashTransaction"
    objects: {
      service: Prisma.$WashServicePayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      promoCode: Prisma.$PromoCodePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceId: string
      customerId: string | null
      quantity: number
      total: number
      paymentMethod: string | null
      vehicleType: string | null
      discount: number | null
      promoCodeId: string | null
      receiptNumber: string | null
      createdAt: Date
    }, ExtArgs["result"]["washTransaction"]>
    composites: {}
  }

  type WashTransactionGetPayload<S extends boolean | null | undefined | WashTransactionDefaultArgs> = $Result.GetResult<Prisma.$WashTransactionPayload, S>

  type WashTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WashTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WashTransactionCountAggregateInputType | true
    }

  export interface WashTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WashTransaction'], meta: { name: 'WashTransaction' } }
    /**
     * Find zero or one WashTransaction that matches the filter.
     * @param {WashTransactionFindUniqueArgs} args - Arguments to find a WashTransaction
     * @example
     * // Get one WashTransaction
     * const washTransaction = await prisma.washTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WashTransactionFindUniqueArgs>(args: SelectSubset<T, WashTransactionFindUniqueArgs<ExtArgs>>): Prisma__WashTransactionClient<$Result.GetResult<Prisma.$WashTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WashTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WashTransactionFindUniqueOrThrowArgs} args - Arguments to find a WashTransaction
     * @example
     * // Get one WashTransaction
     * const washTransaction = await prisma.washTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WashTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, WashTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WashTransactionClient<$Result.GetResult<Prisma.$WashTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WashTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashTransactionFindFirstArgs} args - Arguments to find a WashTransaction
     * @example
     * // Get one WashTransaction
     * const washTransaction = await prisma.washTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WashTransactionFindFirstArgs>(args?: SelectSubset<T, WashTransactionFindFirstArgs<ExtArgs>>): Prisma__WashTransactionClient<$Result.GetResult<Prisma.$WashTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WashTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashTransactionFindFirstOrThrowArgs} args - Arguments to find a WashTransaction
     * @example
     * // Get one WashTransaction
     * const washTransaction = await prisma.washTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WashTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, WashTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WashTransactionClient<$Result.GetResult<Prisma.$WashTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WashTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WashTransactions
     * const washTransactions = await prisma.washTransaction.findMany()
     * 
     * // Get first 10 WashTransactions
     * const washTransactions = await prisma.washTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const washTransactionWithIdOnly = await prisma.washTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WashTransactionFindManyArgs>(args?: SelectSubset<T, WashTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WashTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WashTransaction.
     * @param {WashTransactionCreateArgs} args - Arguments to create a WashTransaction.
     * @example
     * // Create one WashTransaction
     * const WashTransaction = await prisma.washTransaction.create({
     *   data: {
     *     // ... data to create a WashTransaction
     *   }
     * })
     * 
     */
    create<T extends WashTransactionCreateArgs>(args: SelectSubset<T, WashTransactionCreateArgs<ExtArgs>>): Prisma__WashTransactionClient<$Result.GetResult<Prisma.$WashTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WashTransactions.
     * @param {WashTransactionCreateManyArgs} args - Arguments to create many WashTransactions.
     * @example
     * // Create many WashTransactions
     * const washTransaction = await prisma.washTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WashTransactionCreateManyArgs>(args?: SelectSubset<T, WashTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WashTransactions and returns the data saved in the database.
     * @param {WashTransactionCreateManyAndReturnArgs} args - Arguments to create many WashTransactions.
     * @example
     * // Create many WashTransactions
     * const washTransaction = await prisma.washTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WashTransactions and only return the `id`
     * const washTransactionWithIdOnly = await prisma.washTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WashTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, WashTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WashTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WashTransaction.
     * @param {WashTransactionDeleteArgs} args - Arguments to delete one WashTransaction.
     * @example
     * // Delete one WashTransaction
     * const WashTransaction = await prisma.washTransaction.delete({
     *   where: {
     *     // ... filter to delete one WashTransaction
     *   }
     * })
     * 
     */
    delete<T extends WashTransactionDeleteArgs>(args: SelectSubset<T, WashTransactionDeleteArgs<ExtArgs>>): Prisma__WashTransactionClient<$Result.GetResult<Prisma.$WashTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WashTransaction.
     * @param {WashTransactionUpdateArgs} args - Arguments to update one WashTransaction.
     * @example
     * // Update one WashTransaction
     * const washTransaction = await prisma.washTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WashTransactionUpdateArgs>(args: SelectSubset<T, WashTransactionUpdateArgs<ExtArgs>>): Prisma__WashTransactionClient<$Result.GetResult<Prisma.$WashTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WashTransactions.
     * @param {WashTransactionDeleteManyArgs} args - Arguments to filter WashTransactions to delete.
     * @example
     * // Delete a few WashTransactions
     * const { count } = await prisma.washTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WashTransactionDeleteManyArgs>(args?: SelectSubset<T, WashTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WashTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WashTransactions
     * const washTransaction = await prisma.washTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WashTransactionUpdateManyArgs>(args: SelectSubset<T, WashTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WashTransactions and returns the data updated in the database.
     * @param {WashTransactionUpdateManyAndReturnArgs} args - Arguments to update many WashTransactions.
     * @example
     * // Update many WashTransactions
     * const washTransaction = await prisma.washTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WashTransactions and only return the `id`
     * const washTransactionWithIdOnly = await prisma.washTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WashTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, WashTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WashTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WashTransaction.
     * @param {WashTransactionUpsertArgs} args - Arguments to update or create a WashTransaction.
     * @example
     * // Update or create a WashTransaction
     * const washTransaction = await prisma.washTransaction.upsert({
     *   create: {
     *     // ... data to create a WashTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WashTransaction we want to update
     *   }
     * })
     */
    upsert<T extends WashTransactionUpsertArgs>(args: SelectSubset<T, WashTransactionUpsertArgs<ExtArgs>>): Prisma__WashTransactionClient<$Result.GetResult<Prisma.$WashTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WashTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashTransactionCountArgs} args - Arguments to filter WashTransactions to count.
     * @example
     * // Count the number of WashTransactions
     * const count = await prisma.washTransaction.count({
     *   where: {
     *     // ... the filter for the WashTransactions we want to count
     *   }
     * })
    **/
    count<T extends WashTransactionCountArgs>(
      args?: Subset<T, WashTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WashTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WashTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WashTransactionAggregateArgs>(args: Subset<T, WashTransactionAggregateArgs>): Prisma.PrismaPromise<GetWashTransactionAggregateType<T>>

    /**
     * Group by WashTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WashTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WashTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WashTransactionGroupByArgs['orderBy'] }
        : { orderBy?: WashTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WashTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWashTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WashTransaction model
   */
  readonly fields: WashTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WashTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WashTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends WashServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WashServiceDefaultArgs<ExtArgs>>): Prisma__WashServiceClient<$Result.GetResult<Prisma.$WashServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends WashTransaction$customerArgs<ExtArgs> = {}>(args?: Subset<T, WashTransaction$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    promoCode<T extends WashTransaction$promoCodeArgs<ExtArgs> = {}>(args?: Subset<T, WashTransaction$promoCodeArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WashTransaction model
   */
  interface WashTransactionFieldRefs {
    readonly id: FieldRef<"WashTransaction", 'String'>
    readonly serviceId: FieldRef<"WashTransaction", 'String'>
    readonly customerId: FieldRef<"WashTransaction", 'String'>
    readonly quantity: FieldRef<"WashTransaction", 'Int'>
    readonly total: FieldRef<"WashTransaction", 'Float'>
    readonly paymentMethod: FieldRef<"WashTransaction", 'String'>
    readonly vehicleType: FieldRef<"WashTransaction", 'String'>
    readonly discount: FieldRef<"WashTransaction", 'Float'>
    readonly promoCodeId: FieldRef<"WashTransaction", 'String'>
    readonly receiptNumber: FieldRef<"WashTransaction", 'String'>
    readonly createdAt: FieldRef<"WashTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WashTransaction findUnique
   */
  export type WashTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashTransaction
     */
    select?: WashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashTransaction
     */
    omit?: WashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WashTransaction to fetch.
     */
    where: WashTransactionWhereUniqueInput
  }

  /**
   * WashTransaction findUniqueOrThrow
   */
  export type WashTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashTransaction
     */
    select?: WashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashTransaction
     */
    omit?: WashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WashTransaction to fetch.
     */
    where: WashTransactionWhereUniqueInput
  }

  /**
   * WashTransaction findFirst
   */
  export type WashTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashTransaction
     */
    select?: WashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashTransaction
     */
    omit?: WashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WashTransaction to fetch.
     */
    where?: WashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WashTransactions to fetch.
     */
    orderBy?: WashTransactionOrderByWithRelationInput | WashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WashTransactions.
     */
    cursor?: WashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WashTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WashTransactions.
     */
    distinct?: WashTransactionScalarFieldEnum | WashTransactionScalarFieldEnum[]
  }

  /**
   * WashTransaction findFirstOrThrow
   */
  export type WashTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashTransaction
     */
    select?: WashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashTransaction
     */
    omit?: WashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WashTransaction to fetch.
     */
    where?: WashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WashTransactions to fetch.
     */
    orderBy?: WashTransactionOrderByWithRelationInput | WashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WashTransactions.
     */
    cursor?: WashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WashTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WashTransactions.
     */
    distinct?: WashTransactionScalarFieldEnum | WashTransactionScalarFieldEnum[]
  }

  /**
   * WashTransaction findMany
   */
  export type WashTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashTransaction
     */
    select?: WashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashTransaction
     */
    omit?: WashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WashTransactions to fetch.
     */
    where?: WashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WashTransactions to fetch.
     */
    orderBy?: WashTransactionOrderByWithRelationInput | WashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WashTransactions.
     */
    cursor?: WashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WashTransactions.
     */
    skip?: number
    distinct?: WashTransactionScalarFieldEnum | WashTransactionScalarFieldEnum[]
  }

  /**
   * WashTransaction create
   */
  export type WashTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashTransaction
     */
    select?: WashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashTransaction
     */
    omit?: WashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a WashTransaction.
     */
    data: XOR<WashTransactionCreateInput, WashTransactionUncheckedCreateInput>
  }

  /**
   * WashTransaction createMany
   */
  export type WashTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WashTransactions.
     */
    data: WashTransactionCreateManyInput | WashTransactionCreateManyInput[]
  }

  /**
   * WashTransaction createManyAndReturn
   */
  export type WashTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashTransaction
     */
    select?: WashTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WashTransaction
     */
    omit?: WashTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many WashTransactions.
     */
    data: WashTransactionCreateManyInput | WashTransactionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WashTransaction update
   */
  export type WashTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashTransaction
     */
    select?: WashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashTransaction
     */
    omit?: WashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a WashTransaction.
     */
    data: XOR<WashTransactionUpdateInput, WashTransactionUncheckedUpdateInput>
    /**
     * Choose, which WashTransaction to update.
     */
    where: WashTransactionWhereUniqueInput
  }

  /**
   * WashTransaction updateMany
   */
  export type WashTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WashTransactions.
     */
    data: XOR<WashTransactionUpdateManyMutationInput, WashTransactionUncheckedUpdateManyInput>
    /**
     * Filter which WashTransactions to update
     */
    where?: WashTransactionWhereInput
    /**
     * Limit how many WashTransactions to update.
     */
    limit?: number
  }

  /**
   * WashTransaction updateManyAndReturn
   */
  export type WashTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashTransaction
     */
    select?: WashTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WashTransaction
     */
    omit?: WashTransactionOmit<ExtArgs> | null
    /**
     * The data used to update WashTransactions.
     */
    data: XOR<WashTransactionUpdateManyMutationInput, WashTransactionUncheckedUpdateManyInput>
    /**
     * Filter which WashTransactions to update
     */
    where?: WashTransactionWhereInput
    /**
     * Limit how many WashTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WashTransaction upsert
   */
  export type WashTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashTransaction
     */
    select?: WashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashTransaction
     */
    omit?: WashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the WashTransaction to update in case it exists.
     */
    where: WashTransactionWhereUniqueInput
    /**
     * In case the WashTransaction found by the `where` argument doesn't exist, create a new WashTransaction with this data.
     */
    create: XOR<WashTransactionCreateInput, WashTransactionUncheckedCreateInput>
    /**
     * In case the WashTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WashTransactionUpdateInput, WashTransactionUncheckedUpdateInput>
  }

  /**
   * WashTransaction delete
   */
  export type WashTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashTransaction
     */
    select?: WashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashTransaction
     */
    omit?: WashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashTransactionInclude<ExtArgs> | null
    /**
     * Filter which WashTransaction to delete.
     */
    where: WashTransactionWhereUniqueInput
  }

  /**
   * WashTransaction deleteMany
   */
  export type WashTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WashTransactions to delete
     */
    where?: WashTransactionWhereInput
    /**
     * Limit how many WashTransactions to delete.
     */
    limit?: number
  }

  /**
   * WashTransaction.customer
   */
  export type WashTransaction$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * WashTransaction.promoCode
   */
  export type WashTransaction$promoCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    where?: PromoCodeWhereInput
  }

  /**
   * WashTransaction without action
   */
  export type WashTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashTransaction
     */
    select?: WashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashTransaction
     */
    omit?: WashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashTransactionInclude<ExtArgs> | null
  }


  /**
   * Model PromoCode
   */

  export type AggregatePromoCode = {
    _count: PromoCodeCountAggregateOutputType | null
    _avg: PromoCodeAvgAggregateOutputType | null
    _sum: PromoCodeSumAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  export type PromoCodeAvgAggregateOutputType = {
    discount: number | null
    usageLimit: number | null
    usageCount: number | null
  }

  export type PromoCodeSumAggregateOutputType = {
    discount: number | null
    usageLimit: number | null
    usageCount: number | null
  }

  export type PromoCodeMinAggregateOutputType = {
    id: string | null
    code: string | null
    discount: number | null
    type: string | null
    expiry: Date | null
    usageLimit: number | null
    usageCount: number | null
    createdAt: Date | null
  }

  export type PromoCodeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    discount: number | null
    type: string | null
    expiry: Date | null
    usageLimit: number | null
    usageCount: number | null
    createdAt: Date | null
  }

  export type PromoCodeCountAggregateOutputType = {
    id: number
    code: number
    discount: number
    type: number
    expiry: number
    usageLimit: number
    usageCount: number
    createdAt: number
    _all: number
  }


  export type PromoCodeAvgAggregateInputType = {
    discount?: true
    usageLimit?: true
    usageCount?: true
  }

  export type PromoCodeSumAggregateInputType = {
    discount?: true
    usageLimit?: true
    usageCount?: true
  }

  export type PromoCodeMinAggregateInputType = {
    id?: true
    code?: true
    discount?: true
    type?: true
    expiry?: true
    usageLimit?: true
    usageCount?: true
    createdAt?: true
  }

  export type PromoCodeMaxAggregateInputType = {
    id?: true
    code?: true
    discount?: true
    type?: true
    expiry?: true
    usageLimit?: true
    usageCount?: true
    createdAt?: true
  }

  export type PromoCodeCountAggregateInputType = {
    id?: true
    code?: true
    discount?: true
    type?: true
    expiry?: true
    usageLimit?: true
    usageCount?: true
    createdAt?: true
    _all?: true
  }

  export type PromoCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCode to aggregate.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromoCodes
    **/
    _count?: true | PromoCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromoCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromoCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromoCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromoCodeMaxAggregateInputType
  }

  export type GetPromoCodeAggregateType<T extends PromoCodeAggregateArgs> = {
        [P in keyof T & keyof AggregatePromoCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromoCode[P]>
      : GetScalarType<T[P], AggregatePromoCode[P]>
  }




  export type PromoCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeWhereInput
    orderBy?: PromoCodeOrderByWithAggregationInput | PromoCodeOrderByWithAggregationInput[]
    by: PromoCodeScalarFieldEnum[] | PromoCodeScalarFieldEnum
    having?: PromoCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromoCodeCountAggregateInputType | true
    _avg?: PromoCodeAvgAggregateInputType
    _sum?: PromoCodeSumAggregateInputType
    _min?: PromoCodeMinAggregateInputType
    _max?: PromoCodeMaxAggregateInputType
  }

  export type PromoCodeGroupByOutputType = {
    id: string
    code: string
    discount: number
    type: string
    expiry: Date | null
    usageLimit: number | null
    usageCount: number
    createdAt: Date
    _count: PromoCodeCountAggregateOutputType | null
    _avg: PromoCodeAvgAggregateOutputType | null
    _sum: PromoCodeSumAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  type GetPromoCodeGroupByPayload<T extends PromoCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromoCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromoCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
            : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
        }
      >
    >


  export type PromoCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    discount?: boolean
    type?: boolean
    expiry?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    createdAt?: boolean
    transactions?: boolean | PromoCode$transactionsArgs<ExtArgs>
    _count?: boolean | PromoCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    discount?: boolean
    type?: boolean
    expiry?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    discount?: boolean
    type?: boolean
    expiry?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectScalar = {
    id?: boolean
    code?: boolean
    discount?: boolean
    type?: boolean
    expiry?: boolean
    usageLimit?: boolean
    usageCount?: boolean
    createdAt?: boolean
  }

  export type PromoCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "discount" | "type" | "expiry" | "usageLimit" | "usageCount" | "createdAt", ExtArgs["result"]["promoCode"]>
  export type PromoCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | PromoCode$transactionsArgs<ExtArgs>
    _count?: boolean | PromoCodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PromoCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PromoCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PromoCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromoCode"
    objects: {
      transactions: Prisma.$WashTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      discount: number
      type: string
      expiry: Date | null
      usageLimit: number | null
      usageCount: number
      createdAt: Date
    }, ExtArgs["result"]["promoCode"]>
    composites: {}
  }

  type PromoCodeGetPayload<S extends boolean | null | undefined | PromoCodeDefaultArgs> = $Result.GetResult<Prisma.$PromoCodePayload, S>

  type PromoCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromoCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromoCodeCountAggregateInputType | true
    }

  export interface PromoCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromoCode'], meta: { name: 'PromoCode' } }
    /**
     * Find zero or one PromoCode that matches the filter.
     * @param {PromoCodeFindUniqueArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromoCodeFindUniqueArgs>(args: SelectSubset<T, PromoCodeFindUniqueArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PromoCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromoCodeFindUniqueOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromoCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, PromoCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromoCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromoCodeFindFirstArgs>(args?: SelectSubset<T, PromoCodeFindFirstArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromoCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromoCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, PromoCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PromoCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromoCodes
     * const promoCodes = await prisma.promoCode.findMany()
     * 
     * // Get first 10 PromoCodes
     * const promoCodes = await prisma.promoCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromoCodeFindManyArgs>(args?: SelectSubset<T, PromoCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PromoCode.
     * @param {PromoCodeCreateArgs} args - Arguments to create a PromoCode.
     * @example
     * // Create one PromoCode
     * const PromoCode = await prisma.promoCode.create({
     *   data: {
     *     // ... data to create a PromoCode
     *   }
     * })
     * 
     */
    create<T extends PromoCodeCreateArgs>(args: SelectSubset<T, PromoCodeCreateArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PromoCodes.
     * @param {PromoCodeCreateManyArgs} args - Arguments to create many PromoCodes.
     * @example
     * // Create many PromoCodes
     * const promoCode = await prisma.promoCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromoCodeCreateManyArgs>(args?: SelectSubset<T, PromoCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromoCodes and returns the data saved in the database.
     * @param {PromoCodeCreateManyAndReturnArgs} args - Arguments to create many PromoCodes.
     * @example
     * // Create many PromoCodes
     * const promoCode = await prisma.promoCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromoCodes and only return the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromoCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, PromoCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PromoCode.
     * @param {PromoCodeDeleteArgs} args - Arguments to delete one PromoCode.
     * @example
     * // Delete one PromoCode
     * const PromoCode = await prisma.promoCode.delete({
     *   where: {
     *     // ... filter to delete one PromoCode
     *   }
     * })
     * 
     */
    delete<T extends PromoCodeDeleteArgs>(args: SelectSubset<T, PromoCodeDeleteArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PromoCode.
     * @param {PromoCodeUpdateArgs} args - Arguments to update one PromoCode.
     * @example
     * // Update one PromoCode
     * const promoCode = await prisma.promoCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromoCodeUpdateArgs>(args: SelectSubset<T, PromoCodeUpdateArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PromoCodes.
     * @param {PromoCodeDeleteManyArgs} args - Arguments to filter PromoCodes to delete.
     * @example
     * // Delete a few PromoCodes
     * const { count } = await prisma.promoCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromoCodeDeleteManyArgs>(args?: SelectSubset<T, PromoCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromoCodes
     * const promoCode = await prisma.promoCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromoCodeUpdateManyArgs>(args: SelectSubset<T, PromoCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodes and returns the data updated in the database.
     * @param {PromoCodeUpdateManyAndReturnArgs} args - Arguments to update many PromoCodes.
     * @example
     * // Update many PromoCodes
     * const promoCode = await prisma.promoCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PromoCodes and only return the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromoCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, PromoCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PromoCode.
     * @param {PromoCodeUpsertArgs} args - Arguments to update or create a PromoCode.
     * @example
     * // Update or create a PromoCode
     * const promoCode = await prisma.promoCode.upsert({
     *   create: {
     *     // ... data to create a PromoCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromoCode we want to update
     *   }
     * })
     */
    upsert<T extends PromoCodeUpsertArgs>(args: SelectSubset<T, PromoCodeUpsertArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeCountArgs} args - Arguments to filter PromoCodes to count.
     * @example
     * // Count the number of PromoCodes
     * const count = await prisma.promoCode.count({
     *   where: {
     *     // ... the filter for the PromoCodes we want to count
     *   }
     * })
    **/
    count<T extends PromoCodeCountArgs>(
      args?: Subset<T, PromoCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromoCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromoCodeAggregateArgs>(args: Subset<T, PromoCodeAggregateArgs>): Prisma.PrismaPromise<GetPromoCodeAggregateType<T>>

    /**
     * Group by PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromoCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromoCodeGroupByArgs['orderBy'] }
        : { orderBy?: PromoCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromoCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromoCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromoCode model
   */
  readonly fields: PromoCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromoCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromoCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends PromoCode$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, PromoCode$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WashTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromoCode model
   */
  interface PromoCodeFieldRefs {
    readonly id: FieldRef<"PromoCode", 'String'>
    readonly code: FieldRef<"PromoCode", 'String'>
    readonly discount: FieldRef<"PromoCode", 'Float'>
    readonly type: FieldRef<"PromoCode", 'String'>
    readonly expiry: FieldRef<"PromoCode", 'DateTime'>
    readonly usageLimit: FieldRef<"PromoCode", 'Int'>
    readonly usageCount: FieldRef<"PromoCode", 'Int'>
    readonly createdAt: FieldRef<"PromoCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromoCode findUnique
   */
  export type PromoCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findUniqueOrThrow
   */
  export type PromoCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findFirst
   */
  export type PromoCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode findFirstOrThrow
   */
  export type PromoCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode findMany
   */
  export type PromoCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCodes to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode create
   */
  export type PromoCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a PromoCode.
     */
    data: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
  }

  /**
   * PromoCode createMany
   */
  export type PromoCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromoCodes.
     */
    data: PromoCodeCreateManyInput | PromoCodeCreateManyInput[]
  }

  /**
   * PromoCode createManyAndReturn
   */
  export type PromoCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * The data used to create many PromoCodes.
     */
    data: PromoCodeCreateManyInput | PromoCodeCreateManyInput[]
  }

  /**
   * PromoCode update
   */
  export type PromoCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a PromoCode.
     */
    data: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
    /**
     * Choose, which PromoCode to update.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode updateMany
   */
  export type PromoCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromoCodes.
     */
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodes to update
     */
    where?: PromoCodeWhereInput
    /**
     * Limit how many PromoCodes to update.
     */
    limit?: number
  }

  /**
   * PromoCode updateManyAndReturn
   */
  export type PromoCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * The data used to update PromoCodes.
     */
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodes to update
     */
    where?: PromoCodeWhereInput
    /**
     * Limit how many PromoCodes to update.
     */
    limit?: number
  }

  /**
   * PromoCode upsert
   */
  export type PromoCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the PromoCode to update in case it exists.
     */
    where: PromoCodeWhereUniqueInput
    /**
     * In case the PromoCode found by the `where` argument doesn't exist, create a new PromoCode with this data.
     */
    create: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
    /**
     * In case the PromoCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
  }

  /**
   * PromoCode delete
   */
  export type PromoCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter which PromoCode to delete.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode deleteMany
   */
  export type PromoCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCodes to delete
     */
    where?: PromoCodeWhereInput
    /**
     * Limit how many PromoCodes to delete.
     */
    limit?: number
  }

  /**
   * PromoCode.transactions
   */
  export type PromoCode$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WashTransaction
     */
    select?: WashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WashTransaction
     */
    omit?: WashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WashTransactionInclude<ExtArgs> | null
    where?: WashTransactionWhereInput
    orderBy?: WashTransactionOrderByWithRelationInput | WashTransactionOrderByWithRelationInput[]
    cursor?: WashTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WashTransactionScalarFieldEnum | WashTransactionScalarFieldEnum[]
  }

  /**
   * PromoCode without action
   */
  export type PromoCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
  }


  /**
   * Model InventoryItem
   */

  export type AggregateInventoryItem = {
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  export type InventoryItemAvgAggregateOutputType = {
    quantity: number | null
    minStock: number | null
    costPrice: number | null
  }

  export type InventoryItemSumAggregateOutputType = {
    quantity: number | null
    minStock: number | null
    costPrice: number | null
  }

  export type InventoryItemMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    quantity: number | null
    minStock: number | null
    unit: string | null
    supplier: string | null
    costPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryItemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    quantity: number | null
    minStock: number | null
    unit: string | null
    supplier: string | null
    costPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryItemCountAggregateOutputType = {
    id: number
    name: number
    description: number
    quantity: number
    minStock: number
    unit: number
    supplier: number
    costPrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryItemAvgAggregateInputType = {
    quantity?: true
    minStock?: true
    costPrice?: true
  }

  export type InventoryItemSumAggregateInputType = {
    quantity?: true
    minStock?: true
    costPrice?: true
  }

  export type InventoryItemMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    quantity?: true
    minStock?: true
    unit?: true
    supplier?: true
    costPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryItemMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    quantity?: true
    minStock?: true
    unit?: true
    supplier?: true
    costPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryItemCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    quantity?: true
    minStock?: true
    unit?: true
    supplier?: true
    costPrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItem to aggregate.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryItems
    **/
    _count?: true | InventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryItemMaxAggregateInputType
  }

  export type GetInventoryItemAggregateType<T extends InventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryItem[P]>
      : GetScalarType<T[P], AggregateInventoryItem[P]>
  }




  export type InventoryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithAggregationInput | InventoryItemOrderByWithAggregationInput[]
    by: InventoryItemScalarFieldEnum[] | InventoryItemScalarFieldEnum
    having?: InventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryItemCountAggregateInputType | true
    _avg?: InventoryItemAvgAggregateInputType
    _sum?: InventoryItemSumAggregateInputType
    _min?: InventoryItemMinAggregateInputType
    _max?: InventoryItemMaxAggregateInputType
  }

  export type InventoryItemGroupByOutputType = {
    id: string
    name: string
    description: string | null
    quantity: number
    minStock: number
    unit: string
    supplier: string | null
    costPrice: number | null
    createdAt: Date
    updatedAt: Date
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  type GetInventoryItemGroupByPayload<T extends InventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type InventoryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    minStock?: boolean
    unit?: boolean
    supplier?: boolean
    costPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usages?: boolean | InventoryItem$usagesArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    minStock?: boolean
    unit?: boolean
    supplier?: boolean
    costPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    minStock?: boolean
    unit?: boolean
    supplier?: boolean
    costPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    minStock?: boolean
    unit?: boolean
    supplier?: boolean
    costPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "quantity" | "minStock" | "unit" | "supplier" | "costPrice" | "createdAt" | "updatedAt", ExtArgs["result"]["inventoryItem"]>
  export type InventoryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usages?: boolean | InventoryItem$usagesArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InventoryItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InventoryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryItem"
    objects: {
      usages: Prisma.$InventoryUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      quantity: number
      minStock: number
      unit: string
      supplier: string | null
      costPrice: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventoryItem"]>
    composites: {}
  }

  type InventoryItemGetPayload<S extends boolean | null | undefined | InventoryItemDefaultArgs> = $Result.GetResult<Prisma.$InventoryItemPayload, S>

  type InventoryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryItemCountAggregateInputType | true
    }

  export interface InventoryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryItem'], meta: { name: 'InventoryItem' } }
    /**
     * Find zero or one InventoryItem that matches the filter.
     * @param {InventoryItemFindUniqueArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryItemFindUniqueArgs>(args: SelectSubset<T, InventoryItemFindUniqueArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryItemFindUniqueOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryItemFindFirstArgs>(args?: SelectSubset<T, InventoryItemFindFirstArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany()
     * 
     * // Get first 10 InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryItemFindManyArgs>(args?: SelectSubset<T, InventoryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryItem.
     * @param {InventoryItemCreateArgs} args - Arguments to create a InventoryItem.
     * @example
     * // Create one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.create({
     *   data: {
     *     // ... data to create a InventoryItem
     *   }
     * })
     * 
     */
    create<T extends InventoryItemCreateArgs>(args: SelectSubset<T, InventoryItemCreateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryItems.
     * @param {InventoryItemCreateManyArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryItemCreateManyArgs>(args?: SelectSubset<T, InventoryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryItems and returns the data saved in the database.
     * @param {InventoryItemCreateManyAndReturnArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryItem.
     * @param {InventoryItemDeleteArgs} args - Arguments to delete one InventoryItem.
     * @example
     * // Delete one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.delete({
     *   where: {
     *     // ... filter to delete one InventoryItem
     *   }
     * })
     * 
     */
    delete<T extends InventoryItemDeleteArgs>(args: SelectSubset<T, InventoryItemDeleteArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryItem.
     * @param {InventoryItemUpdateArgs} args - Arguments to update one InventoryItem.
     * @example
     * // Update one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryItemUpdateArgs>(args: SelectSubset<T, InventoryItemUpdateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryItems.
     * @param {InventoryItemDeleteManyArgs} args - Arguments to filter InventoryItems to delete.
     * @example
     * // Delete a few InventoryItems
     * const { count } = await prisma.inventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryItemDeleteManyArgs>(args?: SelectSubset<T, InventoryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryItemUpdateManyArgs>(args: SelectSubset<T, InventoryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems and returns the data updated in the database.
     * @param {InventoryItemUpdateManyAndReturnArgs} args - Arguments to update many InventoryItems.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryItem.
     * @param {InventoryItemUpsertArgs} args - Arguments to update or create a InventoryItem.
     * @example
     * // Update or create a InventoryItem
     * const inventoryItem = await prisma.inventoryItem.upsert({
     *   create: {
     *     // ... data to create a InventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryItem we want to update
     *   }
     * })
     */
    upsert<T extends InventoryItemUpsertArgs>(args: SelectSubset<T, InventoryItemUpsertArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemCountArgs} args - Arguments to filter InventoryItems to count.
     * @example
     * // Count the number of InventoryItems
     * const count = await prisma.inventoryItem.count({
     *   where: {
     *     // ... the filter for the InventoryItems we want to count
     *   }
     * })
    **/
    count<T extends InventoryItemCountArgs>(
      args?: Subset<T, InventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryItemAggregateArgs>(args: Subset<T, InventoryItemAggregateArgs>): Prisma.PrismaPromise<GetInventoryItemAggregateType<T>>

    /**
     * Group by InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: InventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryItem model
   */
  readonly fields: InventoryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usages<T extends InventoryItem$usagesArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$usagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryItem model
   */
  interface InventoryItemFieldRefs {
    readonly id: FieldRef<"InventoryItem", 'String'>
    readonly name: FieldRef<"InventoryItem", 'String'>
    readonly description: FieldRef<"InventoryItem", 'String'>
    readonly quantity: FieldRef<"InventoryItem", 'Int'>
    readonly minStock: FieldRef<"InventoryItem", 'Int'>
    readonly unit: FieldRef<"InventoryItem", 'String'>
    readonly supplier: FieldRef<"InventoryItem", 'String'>
    readonly costPrice: FieldRef<"InventoryItem", 'Float'>
    readonly createdAt: FieldRef<"InventoryItem", 'DateTime'>
    readonly updatedAt: FieldRef<"InventoryItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryItem findUnique
   */
  export type InventoryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findUniqueOrThrow
   */
  export type InventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findFirst
   */
  export type InventoryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findFirstOrThrow
   */
  export type InventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findMany
   */
  export type InventoryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItems to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem create
   */
  export type InventoryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryItem.
     */
    data: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
  }

  /**
   * InventoryItem createMany
   */
  export type InventoryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
  }

  /**
   * InventoryItem createManyAndReturn
   */
  export type InventoryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
  }

  /**
   * InventoryItem update
   */
  export type InventoryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryItem.
     */
    data: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
    /**
     * Choose, which InventoryItem to update.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem updateMany
   */
  export type InventoryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
  }

  /**
   * InventoryItem updateManyAndReturn
   */
  export type InventoryItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
  }

  /**
   * InventoryItem upsert
   */
  export type InventoryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryItem to update in case it exists.
     */
    where: InventoryItemWhereUniqueInput
    /**
     * In case the InventoryItem found by the `where` argument doesn't exist, create a new InventoryItem with this data.
     */
    create: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
    /**
     * In case the InventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
  }

  /**
   * InventoryItem delete
   */
  export type InventoryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter which InventoryItem to delete.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem deleteMany
   */
  export type InventoryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItems to delete
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to delete.
     */
    limit?: number
  }

  /**
   * InventoryItem.usages
   */
  export type InventoryItem$usagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    where?: InventoryUsageWhereInput
    orderBy?: InventoryUsageOrderByWithRelationInput | InventoryUsageOrderByWithRelationInput[]
    cursor?: InventoryUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryUsageScalarFieldEnum | InventoryUsageScalarFieldEnum[]
  }

  /**
   * InventoryItem without action
   */
  export type InventoryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
  }


  /**
   * Model InventoryUsage
   */

  export type AggregateInventoryUsage = {
    _count: InventoryUsageCountAggregateOutputType | null
    _avg: InventoryUsageAvgAggregateOutputType | null
    _sum: InventoryUsageSumAggregateOutputType | null
    _min: InventoryUsageMinAggregateOutputType | null
    _max: InventoryUsageMaxAggregateOutputType | null
  }

  export type InventoryUsageAvgAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryUsageSumAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryUsageMinAggregateOutputType = {
    id: string | null
    itemId: string | null
    quantity: number | null
    reason: string | null
    transactionId: string | null
    createdAt: Date | null
  }

  export type InventoryUsageMaxAggregateOutputType = {
    id: string | null
    itemId: string | null
    quantity: number | null
    reason: string | null
    transactionId: string | null
    createdAt: Date | null
  }

  export type InventoryUsageCountAggregateOutputType = {
    id: number
    itemId: number
    quantity: number
    reason: number
    transactionId: number
    createdAt: number
    _all: number
  }


  export type InventoryUsageAvgAggregateInputType = {
    quantity?: true
  }

  export type InventoryUsageSumAggregateInputType = {
    quantity?: true
  }

  export type InventoryUsageMinAggregateInputType = {
    id?: true
    itemId?: true
    quantity?: true
    reason?: true
    transactionId?: true
    createdAt?: true
  }

  export type InventoryUsageMaxAggregateInputType = {
    id?: true
    itemId?: true
    quantity?: true
    reason?: true
    transactionId?: true
    createdAt?: true
  }

  export type InventoryUsageCountAggregateInputType = {
    id?: true
    itemId?: true
    quantity?: true
    reason?: true
    transactionId?: true
    createdAt?: true
    _all?: true
  }

  export type InventoryUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryUsage to aggregate.
     */
    where?: InventoryUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUsages to fetch.
     */
    orderBy?: InventoryUsageOrderByWithRelationInput | InventoryUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryUsages
    **/
    _count?: true | InventoryUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryUsageMaxAggregateInputType
  }

  export type GetInventoryUsageAggregateType<T extends InventoryUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryUsage[P]>
      : GetScalarType<T[P], AggregateInventoryUsage[P]>
  }




  export type InventoryUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryUsageWhereInput
    orderBy?: InventoryUsageOrderByWithAggregationInput | InventoryUsageOrderByWithAggregationInput[]
    by: InventoryUsageScalarFieldEnum[] | InventoryUsageScalarFieldEnum
    having?: InventoryUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryUsageCountAggregateInputType | true
    _avg?: InventoryUsageAvgAggregateInputType
    _sum?: InventoryUsageSumAggregateInputType
    _min?: InventoryUsageMinAggregateInputType
    _max?: InventoryUsageMaxAggregateInputType
  }

  export type InventoryUsageGroupByOutputType = {
    id: string
    itemId: string
    quantity: number
    reason: string
    transactionId: string | null
    createdAt: Date
    _count: InventoryUsageCountAggregateOutputType | null
    _avg: InventoryUsageAvgAggregateOutputType | null
    _sum: InventoryUsageSumAggregateOutputType | null
    _min: InventoryUsageMinAggregateOutputType | null
    _max: InventoryUsageMaxAggregateOutputType | null
  }

  type GetInventoryUsageGroupByPayload<T extends InventoryUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryUsageGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryUsageGroupByOutputType[P]>
        }
      >
    >


  export type InventoryUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    quantity?: boolean
    reason?: boolean
    transactionId?: boolean
    createdAt?: boolean
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryUsage"]>

  export type InventoryUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    quantity?: boolean
    reason?: boolean
    transactionId?: boolean
    createdAt?: boolean
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryUsage"]>

  export type InventoryUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    quantity?: boolean
    reason?: boolean
    transactionId?: boolean
    createdAt?: boolean
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryUsage"]>

  export type InventoryUsageSelectScalar = {
    id?: boolean
    itemId?: boolean
    quantity?: boolean
    reason?: boolean
    transactionId?: boolean
    createdAt?: boolean
  }

  export type InventoryUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemId" | "quantity" | "reason" | "transactionId" | "createdAt", ExtArgs["result"]["inventoryUsage"]>
  export type InventoryUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }
  export type InventoryUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }
  export type InventoryUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
  }

  export type $InventoryUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryUsage"
    objects: {
      item: Prisma.$InventoryItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      itemId: string
      quantity: number
      reason: string
      transactionId: string | null
      createdAt: Date
    }, ExtArgs["result"]["inventoryUsage"]>
    composites: {}
  }

  type InventoryUsageGetPayload<S extends boolean | null | undefined | InventoryUsageDefaultArgs> = $Result.GetResult<Prisma.$InventoryUsagePayload, S>

  type InventoryUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryUsageCountAggregateInputType | true
    }

  export interface InventoryUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryUsage'], meta: { name: 'InventoryUsage' } }
    /**
     * Find zero or one InventoryUsage that matches the filter.
     * @param {InventoryUsageFindUniqueArgs} args - Arguments to find a InventoryUsage
     * @example
     * // Get one InventoryUsage
     * const inventoryUsage = await prisma.inventoryUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryUsageFindUniqueArgs>(args: SelectSubset<T, InventoryUsageFindUniqueArgs<ExtArgs>>): Prisma__InventoryUsageClient<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryUsageFindUniqueOrThrowArgs} args - Arguments to find a InventoryUsage
     * @example
     * // Get one InventoryUsage
     * const inventoryUsage = await prisma.inventoryUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryUsageClient<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUsageFindFirstArgs} args - Arguments to find a InventoryUsage
     * @example
     * // Get one InventoryUsage
     * const inventoryUsage = await prisma.inventoryUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryUsageFindFirstArgs>(args?: SelectSubset<T, InventoryUsageFindFirstArgs<ExtArgs>>): Prisma__InventoryUsageClient<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUsageFindFirstOrThrowArgs} args - Arguments to find a InventoryUsage
     * @example
     * // Get one InventoryUsage
     * const inventoryUsage = await prisma.inventoryUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryUsageClient<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryUsages
     * const inventoryUsages = await prisma.inventoryUsage.findMany()
     * 
     * // Get first 10 InventoryUsages
     * const inventoryUsages = await prisma.inventoryUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryUsageWithIdOnly = await prisma.inventoryUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryUsageFindManyArgs>(args?: SelectSubset<T, InventoryUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryUsage.
     * @param {InventoryUsageCreateArgs} args - Arguments to create a InventoryUsage.
     * @example
     * // Create one InventoryUsage
     * const InventoryUsage = await prisma.inventoryUsage.create({
     *   data: {
     *     // ... data to create a InventoryUsage
     *   }
     * })
     * 
     */
    create<T extends InventoryUsageCreateArgs>(args: SelectSubset<T, InventoryUsageCreateArgs<ExtArgs>>): Prisma__InventoryUsageClient<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryUsages.
     * @param {InventoryUsageCreateManyArgs} args - Arguments to create many InventoryUsages.
     * @example
     * // Create many InventoryUsages
     * const inventoryUsage = await prisma.inventoryUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryUsageCreateManyArgs>(args?: SelectSubset<T, InventoryUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryUsages and returns the data saved in the database.
     * @param {InventoryUsageCreateManyAndReturnArgs} args - Arguments to create many InventoryUsages.
     * @example
     * // Create many InventoryUsages
     * const inventoryUsage = await prisma.inventoryUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryUsages and only return the `id`
     * const inventoryUsageWithIdOnly = await prisma.inventoryUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryUsage.
     * @param {InventoryUsageDeleteArgs} args - Arguments to delete one InventoryUsage.
     * @example
     * // Delete one InventoryUsage
     * const InventoryUsage = await prisma.inventoryUsage.delete({
     *   where: {
     *     // ... filter to delete one InventoryUsage
     *   }
     * })
     * 
     */
    delete<T extends InventoryUsageDeleteArgs>(args: SelectSubset<T, InventoryUsageDeleteArgs<ExtArgs>>): Prisma__InventoryUsageClient<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryUsage.
     * @param {InventoryUsageUpdateArgs} args - Arguments to update one InventoryUsage.
     * @example
     * // Update one InventoryUsage
     * const inventoryUsage = await prisma.inventoryUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUsageUpdateArgs>(args: SelectSubset<T, InventoryUsageUpdateArgs<ExtArgs>>): Prisma__InventoryUsageClient<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryUsages.
     * @param {InventoryUsageDeleteManyArgs} args - Arguments to filter InventoryUsages to delete.
     * @example
     * // Delete a few InventoryUsages
     * const { count } = await prisma.inventoryUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryUsageDeleteManyArgs>(args?: SelectSubset<T, InventoryUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryUsages
     * const inventoryUsage = await prisma.inventoryUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUsageUpdateManyArgs>(args: SelectSubset<T, InventoryUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryUsages and returns the data updated in the database.
     * @param {InventoryUsageUpdateManyAndReturnArgs} args - Arguments to update many InventoryUsages.
     * @example
     * // Update many InventoryUsages
     * const inventoryUsage = await prisma.inventoryUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryUsages and only return the `id`
     * const inventoryUsageWithIdOnly = await prisma.inventoryUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryUsage.
     * @param {InventoryUsageUpsertArgs} args - Arguments to update or create a InventoryUsage.
     * @example
     * // Update or create a InventoryUsage
     * const inventoryUsage = await prisma.inventoryUsage.upsert({
     *   create: {
     *     // ... data to create a InventoryUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryUsage we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUsageUpsertArgs>(args: SelectSubset<T, InventoryUsageUpsertArgs<ExtArgs>>): Prisma__InventoryUsageClient<$Result.GetResult<Prisma.$InventoryUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUsageCountArgs} args - Arguments to filter InventoryUsages to count.
     * @example
     * // Count the number of InventoryUsages
     * const count = await prisma.inventoryUsage.count({
     *   where: {
     *     // ... the filter for the InventoryUsages we want to count
     *   }
     * })
    **/
    count<T extends InventoryUsageCountArgs>(
      args?: Subset<T, InventoryUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryUsageAggregateArgs>(args: Subset<T, InventoryUsageAggregateArgs>): Prisma.PrismaPromise<GetInventoryUsageAggregateType<T>>

    /**
     * Group by InventoryUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryUsageGroupByArgs['orderBy'] }
        : { orderBy?: InventoryUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryUsage model
   */
  readonly fields: InventoryUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends InventoryItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItemDefaultArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryUsage model
   */
  interface InventoryUsageFieldRefs {
    readonly id: FieldRef<"InventoryUsage", 'String'>
    readonly itemId: FieldRef<"InventoryUsage", 'String'>
    readonly quantity: FieldRef<"InventoryUsage", 'Int'>
    readonly reason: FieldRef<"InventoryUsage", 'String'>
    readonly transactionId: FieldRef<"InventoryUsage", 'String'>
    readonly createdAt: FieldRef<"InventoryUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryUsage findUnique
   */
  export type InventoryUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUsage to fetch.
     */
    where: InventoryUsageWhereUniqueInput
  }

  /**
   * InventoryUsage findUniqueOrThrow
   */
  export type InventoryUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUsage to fetch.
     */
    where: InventoryUsageWhereUniqueInput
  }

  /**
   * InventoryUsage findFirst
   */
  export type InventoryUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUsage to fetch.
     */
    where?: InventoryUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUsages to fetch.
     */
    orderBy?: InventoryUsageOrderByWithRelationInput | InventoryUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryUsages.
     */
    cursor?: InventoryUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryUsages.
     */
    distinct?: InventoryUsageScalarFieldEnum | InventoryUsageScalarFieldEnum[]
  }

  /**
   * InventoryUsage findFirstOrThrow
   */
  export type InventoryUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUsage to fetch.
     */
    where?: InventoryUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUsages to fetch.
     */
    orderBy?: InventoryUsageOrderByWithRelationInput | InventoryUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryUsages.
     */
    cursor?: InventoryUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryUsages.
     */
    distinct?: InventoryUsageScalarFieldEnum | InventoryUsageScalarFieldEnum[]
  }

  /**
   * InventoryUsage findMany
   */
  export type InventoryUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    /**
     * Filter, which InventoryUsages to fetch.
     */
    where?: InventoryUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryUsages to fetch.
     */
    orderBy?: InventoryUsageOrderByWithRelationInput | InventoryUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryUsages.
     */
    cursor?: InventoryUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryUsages.
     */
    skip?: number
    distinct?: InventoryUsageScalarFieldEnum | InventoryUsageScalarFieldEnum[]
  }

  /**
   * InventoryUsage create
   */
  export type InventoryUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryUsage.
     */
    data: XOR<InventoryUsageCreateInput, InventoryUsageUncheckedCreateInput>
  }

  /**
   * InventoryUsage createMany
   */
  export type InventoryUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryUsages.
     */
    data: InventoryUsageCreateManyInput | InventoryUsageCreateManyInput[]
  }

  /**
   * InventoryUsage createManyAndReturn
   */
  export type InventoryUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryUsages.
     */
    data: InventoryUsageCreateManyInput | InventoryUsageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryUsage update
   */
  export type InventoryUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryUsage.
     */
    data: XOR<InventoryUsageUpdateInput, InventoryUsageUncheckedUpdateInput>
    /**
     * Choose, which InventoryUsage to update.
     */
    where: InventoryUsageWhereUniqueInput
  }

  /**
   * InventoryUsage updateMany
   */
  export type InventoryUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryUsages.
     */
    data: XOR<InventoryUsageUpdateManyMutationInput, InventoryUsageUncheckedUpdateManyInput>
    /**
     * Filter which InventoryUsages to update
     */
    where?: InventoryUsageWhereInput
    /**
     * Limit how many InventoryUsages to update.
     */
    limit?: number
  }

  /**
   * InventoryUsage updateManyAndReturn
   */
  export type InventoryUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * The data used to update InventoryUsages.
     */
    data: XOR<InventoryUsageUpdateManyMutationInput, InventoryUsageUncheckedUpdateManyInput>
    /**
     * Filter which InventoryUsages to update
     */
    where?: InventoryUsageWhereInput
    /**
     * Limit how many InventoryUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryUsage upsert
   */
  export type InventoryUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryUsage to update in case it exists.
     */
    where: InventoryUsageWhereUniqueInput
    /**
     * In case the InventoryUsage found by the `where` argument doesn't exist, create a new InventoryUsage with this data.
     */
    create: XOR<InventoryUsageCreateInput, InventoryUsageUncheckedCreateInput>
    /**
     * In case the InventoryUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUsageUpdateInput, InventoryUsageUncheckedUpdateInput>
  }

  /**
   * InventoryUsage delete
   */
  export type InventoryUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
    /**
     * Filter which InventoryUsage to delete.
     */
    where: InventoryUsageWhereUniqueInput
  }

  /**
   * InventoryUsage deleteMany
   */
  export type InventoryUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryUsages to delete
     */
    where?: InventoryUsageWhereInput
    /**
     * Limit how many InventoryUsages to delete.
     */
    limit?: number
  }

  /**
   * InventoryUsage without action
   */
  export type InventoryUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryUsage
     */
    select?: InventoryUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryUsage
     */
    omit?: InventoryUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryUsageInclude<ExtArgs> | null
  }


  /**
   * Model Staff
   */

  export type AggregateStaff = {
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  export type StaffMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    role: string | null
    password: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type StaffMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    role: string | null
    password: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type StaffCountAggregateOutputType = {
    id: number
    name: number
    email: number
    role: number
    password: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type StaffMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    role?: true
    password?: true
    isActive?: true
    createdAt?: true
  }

  export type StaffMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    role?: true
    password?: true
    isActive?: true
    createdAt?: true
  }

  export type StaffCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    role?: true
    password?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type StaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to aggregate.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Staff
    **/
    _count?: true | StaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffMaxAggregateInputType
  }

  export type GetStaffAggregateType<T extends StaffAggregateArgs> = {
        [P in keyof T & keyof AggregateStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaff[P]>
      : GetScalarType<T[P], AggregateStaff[P]>
  }




  export type StaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithAggregationInput | StaffOrderByWithAggregationInput[]
    by: StaffScalarFieldEnum[] | StaffScalarFieldEnum
    having?: StaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffCountAggregateInputType | true
    _min?: StaffMinAggregateInputType
    _max?: StaffMaxAggregateInputType
  }

  export type StaffGroupByOutputType = {
    id: string
    name: string
    email: string
    role: string
    password: string
    isActive: boolean
    createdAt: Date
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  type GetStaffGroupByPayload<T extends StaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffGroupByOutputType[P]>
            : GetScalarType<T[P], StaffGroupByOutputType[P]>
        }
      >
    >


  export type StaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
    shifts?: boolean | Staff$shiftsArgs<ExtArgs>
    audits?: boolean | Staff$auditsArgs<ExtArgs>
    _count?: boolean | StaffCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type StaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "role" | "password" | "isActive" | "createdAt", ExtArgs["result"]["staff"]>
  export type StaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shifts?: boolean | Staff$shiftsArgs<ExtArgs>
    audits?: boolean | Staff$auditsArgs<ExtArgs>
    _count?: boolean | StaffCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Staff"
    objects: {
      shifts: Prisma.$StaffShiftPayload<ExtArgs>[]
      audits: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      role: string
      password: string
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["staff"]>
    composites: {}
  }

  type StaffGetPayload<S extends boolean | null | undefined | StaffDefaultArgs> = $Result.GetResult<Prisma.$StaffPayload, S>

  type StaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StaffCountAggregateInputType | true
    }

  export interface StaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Staff'], meta: { name: 'Staff' } }
    /**
     * Find zero or one Staff that matches the filter.
     * @param {StaffFindUniqueArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffFindUniqueArgs>(args: SelectSubset<T, StaffFindUniqueArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Staff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaffFindUniqueOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffFindFirstArgs>(args?: SelectSubset<T, StaffFindFirstArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Staff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staff
     * const staff = await prisma.staff.findMany()
     * 
     * // Get first 10 Staff
     * const staff = await prisma.staff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffWithIdOnly = await prisma.staff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffFindManyArgs>(args?: SelectSubset<T, StaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Staff.
     * @param {StaffCreateArgs} args - Arguments to create a Staff.
     * @example
     * // Create one Staff
     * const Staff = await prisma.staff.create({
     *   data: {
     *     // ... data to create a Staff
     *   }
     * })
     * 
     */
    create<T extends StaffCreateArgs>(args: SelectSubset<T, StaffCreateArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Staff.
     * @param {StaffCreateManyArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffCreateManyArgs>(args?: SelectSubset<T, StaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Staff and returns the data saved in the database.
     * @param {StaffCreateManyAndReturnArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Staff.
     * @param {StaffDeleteArgs} args - Arguments to delete one Staff.
     * @example
     * // Delete one Staff
     * const Staff = await prisma.staff.delete({
     *   where: {
     *     // ... filter to delete one Staff
     *   }
     * })
     * 
     */
    delete<T extends StaffDeleteArgs>(args: SelectSubset<T, StaffDeleteArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Staff.
     * @param {StaffUpdateArgs} args - Arguments to update one Staff.
     * @example
     * // Update one Staff
     * const staff = await prisma.staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffUpdateArgs>(args: SelectSubset<T, StaffUpdateArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Staff.
     * @param {StaffDeleteManyArgs} args - Arguments to filter Staff to delete.
     * @example
     * // Delete a few Staff
     * const { count } = await prisma.staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffDeleteManyArgs>(args?: SelectSubset<T, StaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffUpdateManyArgs>(args: SelectSubset<T, StaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff and returns the data updated in the database.
     * @param {StaffUpdateManyAndReturnArgs} args - Arguments to update many Staff.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StaffUpdateManyAndReturnArgs>(args: SelectSubset<T, StaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Staff.
     * @param {StaffUpsertArgs} args - Arguments to update or create a Staff.
     * @example
     * // Update or create a Staff
     * const staff = await prisma.staff.upsert({
     *   create: {
     *     // ... data to create a Staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staff we want to update
     *   }
     * })
     */
    upsert<T extends StaffUpsertArgs>(args: SelectSubset<T, StaffUpsertArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffCountArgs} args - Arguments to filter Staff to count.
     * @example
     * // Count the number of Staff
     * const count = await prisma.staff.count({
     *   where: {
     *     // ... the filter for the Staff we want to count
     *   }
     * })
    **/
    count<T extends StaffCountArgs>(
      args?: Subset<T, StaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffAggregateArgs>(args: Subset<T, StaffAggregateArgs>): Prisma.PrismaPromise<GetStaffAggregateType<T>>

    /**
     * Group by Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffGroupByArgs['orderBy'] }
        : { orderBy?: StaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Staff model
   */
  readonly fields: StaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shifts<T extends Staff$shiftsArgs<ExtArgs> = {}>(args?: Subset<T, Staff$shiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    audits<T extends Staff$auditsArgs<ExtArgs> = {}>(args?: Subset<T, Staff$auditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Staff model
   */
  interface StaffFieldRefs {
    readonly id: FieldRef<"Staff", 'String'>
    readonly name: FieldRef<"Staff", 'String'>
    readonly email: FieldRef<"Staff", 'String'>
    readonly role: FieldRef<"Staff", 'String'>
    readonly password: FieldRef<"Staff", 'String'>
    readonly isActive: FieldRef<"Staff", 'Boolean'>
    readonly createdAt: FieldRef<"Staff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Staff findUnique
   */
  export type StaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findUniqueOrThrow
   */
  export type StaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findFirst
   */
  export type StaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff findFirstOrThrow
   */
  export type StaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff findMany
   */
  export type StaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff create
   */
  export type StaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to create a Staff.
     */
    data: XOR<StaffCreateInput, StaffUncheckedCreateInput>
  }

  /**
   * Staff createMany
   */
  export type StaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[]
  }

  /**
   * Staff createManyAndReturn
   */
  export type StaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[]
  }

  /**
   * Staff update
   */
  export type StaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to update a Staff.
     */
    data: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
    /**
     * Choose, which Staff to update.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff updateMany
   */
  export type StaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to update.
     */
    limit?: number
  }

  /**
   * Staff updateManyAndReturn
   */
  export type StaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to update.
     */
    limit?: number
  }

  /**
   * Staff upsert
   */
  export type StaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The filter to search for the Staff to update in case it exists.
     */
    where: StaffWhereUniqueInput
    /**
     * In case the Staff found by the `where` argument doesn't exist, create a new Staff with this data.
     */
    create: XOR<StaffCreateInput, StaffUncheckedCreateInput>
    /**
     * In case the Staff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
  }

  /**
   * Staff delete
   */
  export type StaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter which Staff to delete.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff deleteMany
   */
  export type StaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to delete
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to delete.
     */
    limit?: number
  }

  /**
   * Staff.shifts
   */
  export type Staff$shiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffShift
     */
    omit?: StaffShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
    where?: StaffShiftWhereInput
    orderBy?: StaffShiftOrderByWithRelationInput | StaffShiftOrderByWithRelationInput[]
    cursor?: StaffShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffShiftScalarFieldEnum | StaffShiftScalarFieldEnum[]
  }

  /**
   * Staff.audits
   */
  export type Staff$auditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Staff without action
   */
  export type StaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
  }


  /**
   * Model StaffShift
   */

  export type AggregateStaffShift = {
    _count: StaffShiftCountAggregateOutputType | null
    _min: StaffShiftMinAggregateOutputType | null
    _max: StaffShiftMaxAggregateOutputType | null
  }

  export type StaffShiftMinAggregateOutputType = {
    id: string | null
    staffId: string | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
  }

  export type StaffShiftMaxAggregateOutputType = {
    id: string | null
    staffId: string | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
  }

  export type StaffShiftCountAggregateOutputType = {
    id: number
    staffId: number
    startTime: number
    endTime: number
    createdAt: number
    _all: number
  }


  export type StaffShiftMinAggregateInputType = {
    id?: true
    staffId?: true
    startTime?: true
    endTime?: true
    createdAt?: true
  }

  export type StaffShiftMaxAggregateInputType = {
    id?: true
    staffId?: true
    startTime?: true
    endTime?: true
    createdAt?: true
  }

  export type StaffShiftCountAggregateInputType = {
    id?: true
    staffId?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    _all?: true
  }

  export type StaffShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffShift to aggregate.
     */
    where?: StaffShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffShifts to fetch.
     */
    orderBy?: StaffShiftOrderByWithRelationInput | StaffShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StaffShifts
    **/
    _count?: true | StaffShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffShiftMaxAggregateInputType
  }

  export type GetStaffShiftAggregateType<T extends StaffShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateStaffShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaffShift[P]>
      : GetScalarType<T[P], AggregateStaffShift[P]>
  }




  export type StaffShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffShiftWhereInput
    orderBy?: StaffShiftOrderByWithAggregationInput | StaffShiftOrderByWithAggregationInput[]
    by: StaffShiftScalarFieldEnum[] | StaffShiftScalarFieldEnum
    having?: StaffShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffShiftCountAggregateInputType | true
    _min?: StaffShiftMinAggregateInputType
    _max?: StaffShiftMaxAggregateInputType
  }

  export type StaffShiftGroupByOutputType = {
    id: string
    staffId: string
    startTime: Date
    endTime: Date | null
    createdAt: Date
    _count: StaffShiftCountAggregateOutputType | null
    _min: StaffShiftMinAggregateOutputType | null
    _max: StaffShiftMaxAggregateOutputType | null
  }

  type GetStaffShiftGroupByPayload<T extends StaffShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffShiftGroupByOutputType[P]>
            : GetScalarType<T[P], StaffShiftGroupByOutputType[P]>
        }
      >
    >


  export type StaffShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffShift"]>

  export type StaffShiftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffShift"]>

  export type StaffShiftSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffShift"]>

  export type StaffShiftSelectScalar = {
    id?: boolean
    staffId?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
  }

  export type StaffShiftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "staffId" | "startTime" | "endTime" | "createdAt", ExtArgs["result"]["staffShift"]>
  export type StaffShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }
  export type StaffShiftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }
  export type StaffShiftIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }

  export type $StaffShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StaffShift"
    objects: {
      staff: Prisma.$StaffPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      staffId: string
      startTime: Date
      endTime: Date | null
      createdAt: Date
    }, ExtArgs["result"]["staffShift"]>
    composites: {}
  }

  type StaffShiftGetPayload<S extends boolean | null | undefined | StaffShiftDefaultArgs> = $Result.GetResult<Prisma.$StaffShiftPayload, S>

  type StaffShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StaffShiftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StaffShiftCountAggregateInputType | true
    }

  export interface StaffShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StaffShift'], meta: { name: 'StaffShift' } }
    /**
     * Find zero or one StaffShift that matches the filter.
     * @param {StaffShiftFindUniqueArgs} args - Arguments to find a StaffShift
     * @example
     * // Get one StaffShift
     * const staffShift = await prisma.staffShift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffShiftFindUniqueArgs>(args: SelectSubset<T, StaffShiftFindUniqueArgs<ExtArgs>>): Prisma__StaffShiftClient<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StaffShift that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaffShiftFindUniqueOrThrowArgs} args - Arguments to find a StaffShift
     * @example
     * // Get one StaffShift
     * const staffShift = await prisma.staffShift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffShiftClient<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaffShift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffShiftFindFirstArgs} args - Arguments to find a StaffShift
     * @example
     * // Get one StaffShift
     * const staffShift = await prisma.staffShift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffShiftFindFirstArgs>(args?: SelectSubset<T, StaffShiftFindFirstArgs<ExtArgs>>): Prisma__StaffShiftClient<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaffShift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffShiftFindFirstOrThrowArgs} args - Arguments to find a StaffShift
     * @example
     * // Get one StaffShift
     * const staffShift = await prisma.staffShift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffShiftClient<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StaffShifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaffShifts
     * const staffShifts = await prisma.staffShift.findMany()
     * 
     * // Get first 10 StaffShifts
     * const staffShifts = await prisma.staffShift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffShiftWithIdOnly = await prisma.staffShift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffShiftFindManyArgs>(args?: SelectSubset<T, StaffShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StaffShift.
     * @param {StaffShiftCreateArgs} args - Arguments to create a StaffShift.
     * @example
     * // Create one StaffShift
     * const StaffShift = await prisma.staffShift.create({
     *   data: {
     *     // ... data to create a StaffShift
     *   }
     * })
     * 
     */
    create<T extends StaffShiftCreateArgs>(args: SelectSubset<T, StaffShiftCreateArgs<ExtArgs>>): Prisma__StaffShiftClient<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StaffShifts.
     * @param {StaffShiftCreateManyArgs} args - Arguments to create many StaffShifts.
     * @example
     * // Create many StaffShifts
     * const staffShift = await prisma.staffShift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffShiftCreateManyArgs>(args?: SelectSubset<T, StaffShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StaffShifts and returns the data saved in the database.
     * @param {StaffShiftCreateManyAndReturnArgs} args - Arguments to create many StaffShifts.
     * @example
     * // Create many StaffShifts
     * const staffShift = await prisma.staffShift.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StaffShifts and only return the `id`
     * const staffShiftWithIdOnly = await prisma.staffShift.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffShiftCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffShiftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StaffShift.
     * @param {StaffShiftDeleteArgs} args - Arguments to delete one StaffShift.
     * @example
     * // Delete one StaffShift
     * const StaffShift = await prisma.staffShift.delete({
     *   where: {
     *     // ... filter to delete one StaffShift
     *   }
     * })
     * 
     */
    delete<T extends StaffShiftDeleteArgs>(args: SelectSubset<T, StaffShiftDeleteArgs<ExtArgs>>): Prisma__StaffShiftClient<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StaffShift.
     * @param {StaffShiftUpdateArgs} args - Arguments to update one StaffShift.
     * @example
     * // Update one StaffShift
     * const staffShift = await prisma.staffShift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffShiftUpdateArgs>(args: SelectSubset<T, StaffShiftUpdateArgs<ExtArgs>>): Prisma__StaffShiftClient<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StaffShifts.
     * @param {StaffShiftDeleteManyArgs} args - Arguments to filter StaffShifts to delete.
     * @example
     * // Delete a few StaffShifts
     * const { count } = await prisma.staffShift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffShiftDeleteManyArgs>(args?: SelectSubset<T, StaffShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffShifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaffShifts
     * const staffShift = await prisma.staffShift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffShiftUpdateManyArgs>(args: SelectSubset<T, StaffShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffShifts and returns the data updated in the database.
     * @param {StaffShiftUpdateManyAndReturnArgs} args - Arguments to update many StaffShifts.
     * @example
     * // Update many StaffShifts
     * const staffShift = await prisma.staffShift.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StaffShifts and only return the `id`
     * const staffShiftWithIdOnly = await prisma.staffShift.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StaffShiftUpdateManyAndReturnArgs>(args: SelectSubset<T, StaffShiftUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StaffShift.
     * @param {StaffShiftUpsertArgs} args - Arguments to update or create a StaffShift.
     * @example
     * // Update or create a StaffShift
     * const staffShift = await prisma.staffShift.upsert({
     *   create: {
     *     // ... data to create a StaffShift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaffShift we want to update
     *   }
     * })
     */
    upsert<T extends StaffShiftUpsertArgs>(args: SelectSubset<T, StaffShiftUpsertArgs<ExtArgs>>): Prisma__StaffShiftClient<$Result.GetResult<Prisma.$StaffShiftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StaffShifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffShiftCountArgs} args - Arguments to filter StaffShifts to count.
     * @example
     * // Count the number of StaffShifts
     * const count = await prisma.staffShift.count({
     *   where: {
     *     // ... the filter for the StaffShifts we want to count
     *   }
     * })
    **/
    count<T extends StaffShiftCountArgs>(
      args?: Subset<T, StaffShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaffShift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffShiftAggregateArgs>(args: Subset<T, StaffShiftAggregateArgs>): Prisma.PrismaPromise<GetStaffShiftAggregateType<T>>

    /**
     * Group by StaffShift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffShiftGroupByArgs['orderBy'] }
        : { orderBy?: StaffShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StaffShift model
   */
  readonly fields: StaffShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StaffShift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staff<T extends StaffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffDefaultArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StaffShift model
   */
  interface StaffShiftFieldRefs {
    readonly id: FieldRef<"StaffShift", 'String'>
    readonly staffId: FieldRef<"StaffShift", 'String'>
    readonly startTime: FieldRef<"StaffShift", 'DateTime'>
    readonly endTime: FieldRef<"StaffShift", 'DateTime'>
    readonly createdAt: FieldRef<"StaffShift", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StaffShift findUnique
   */
  export type StaffShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffShift
     */
    omit?: StaffShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
    /**
     * Filter, which StaffShift to fetch.
     */
    where: StaffShiftWhereUniqueInput
  }

  /**
   * StaffShift findUniqueOrThrow
   */
  export type StaffShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffShift
     */
    omit?: StaffShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
    /**
     * Filter, which StaffShift to fetch.
     */
    where: StaffShiftWhereUniqueInput
  }

  /**
   * StaffShift findFirst
   */
  export type StaffShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffShift
     */
    omit?: StaffShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
    /**
     * Filter, which StaffShift to fetch.
     */
    where?: StaffShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffShifts to fetch.
     */
    orderBy?: StaffShiftOrderByWithRelationInput | StaffShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffShifts.
     */
    cursor?: StaffShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffShifts.
     */
    distinct?: StaffShiftScalarFieldEnum | StaffShiftScalarFieldEnum[]
  }

  /**
   * StaffShift findFirstOrThrow
   */
  export type StaffShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffShift
     */
    omit?: StaffShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
    /**
     * Filter, which StaffShift to fetch.
     */
    where?: StaffShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffShifts to fetch.
     */
    orderBy?: StaffShiftOrderByWithRelationInput | StaffShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffShifts.
     */
    cursor?: StaffShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffShifts.
     */
    distinct?: StaffShiftScalarFieldEnum | StaffShiftScalarFieldEnum[]
  }

  /**
   * StaffShift findMany
   */
  export type StaffShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffShift
     */
    omit?: StaffShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
    /**
     * Filter, which StaffShifts to fetch.
     */
    where?: StaffShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffShifts to fetch.
     */
    orderBy?: StaffShiftOrderByWithRelationInput | StaffShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StaffShifts.
     */
    cursor?: StaffShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffShifts.
     */
    skip?: number
    distinct?: StaffShiftScalarFieldEnum | StaffShiftScalarFieldEnum[]
  }

  /**
   * StaffShift create
   */
  export type StaffShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffShift
     */
    omit?: StaffShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a StaffShift.
     */
    data: XOR<StaffShiftCreateInput, StaffShiftUncheckedCreateInput>
  }

  /**
   * StaffShift createMany
   */
  export type StaffShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StaffShifts.
     */
    data: StaffShiftCreateManyInput | StaffShiftCreateManyInput[]
  }

  /**
   * StaffShift createManyAndReturn
   */
  export type StaffShiftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaffShift
     */
    omit?: StaffShiftOmit<ExtArgs> | null
    /**
     * The data used to create many StaffShifts.
     */
    data: StaffShiftCreateManyInput | StaffShiftCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffShift update
   */
  export type StaffShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffShift
     */
    omit?: StaffShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a StaffShift.
     */
    data: XOR<StaffShiftUpdateInput, StaffShiftUncheckedUpdateInput>
    /**
     * Choose, which StaffShift to update.
     */
    where: StaffShiftWhereUniqueInput
  }

  /**
   * StaffShift updateMany
   */
  export type StaffShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StaffShifts.
     */
    data: XOR<StaffShiftUpdateManyMutationInput, StaffShiftUncheckedUpdateManyInput>
    /**
     * Filter which StaffShifts to update
     */
    where?: StaffShiftWhereInput
    /**
     * Limit how many StaffShifts to update.
     */
    limit?: number
  }

  /**
   * StaffShift updateManyAndReturn
   */
  export type StaffShiftUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaffShift
     */
    omit?: StaffShiftOmit<ExtArgs> | null
    /**
     * The data used to update StaffShifts.
     */
    data: XOR<StaffShiftUpdateManyMutationInput, StaffShiftUncheckedUpdateManyInput>
    /**
     * Filter which StaffShifts to update
     */
    where?: StaffShiftWhereInput
    /**
     * Limit how many StaffShifts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffShift upsert
   */
  export type StaffShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffShift
     */
    omit?: StaffShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the StaffShift to update in case it exists.
     */
    where: StaffShiftWhereUniqueInput
    /**
     * In case the StaffShift found by the `where` argument doesn't exist, create a new StaffShift with this data.
     */
    create: XOR<StaffShiftCreateInput, StaffShiftUncheckedCreateInput>
    /**
     * In case the StaffShift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffShiftUpdateInput, StaffShiftUncheckedUpdateInput>
  }

  /**
   * StaffShift delete
   */
  export type StaffShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffShift
     */
    omit?: StaffShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
    /**
     * Filter which StaffShift to delete.
     */
    where: StaffShiftWhereUniqueInput
  }

  /**
   * StaffShift deleteMany
   */
  export type StaffShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffShifts to delete
     */
    where?: StaffShiftWhereInput
    /**
     * Limit how many StaffShifts to delete.
     */
    limit?: number
  }

  /**
   * StaffShift without action
   */
  export type StaffShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffShift
     */
    select?: StaffShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffShift
     */
    omit?: StaffShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffShiftInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    staffId: string | null
    action: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    staffId: string | null
    action: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    staffId: number
    action: number
    details: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    staffId?: true
    action?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    staffId?: true
    action?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    staffId?: true
    action?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    staffId: string
    action: string
    details: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    staffId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "staffId" | "action" | "details" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      staff: Prisma.$StaffPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      staffId: string
      action: string
      details: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staff<T extends StaffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffDefaultArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly staffId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model BusinessSettings
   */

  export type AggregateBusinessSettings = {
    _count: BusinessSettingsCountAggregateOutputType | null
    _avg: BusinessSettingsAvgAggregateOutputType | null
    _sum: BusinessSettingsSumAggregateOutputType | null
    _min: BusinessSettingsMinAggregateOutputType | null
    _max: BusinessSettingsMaxAggregateOutputType | null
  }

  export type BusinessSettingsAvgAggregateOutputType = {
    taxRate: number | null
  }

  export type BusinessSettingsSumAggregateOutputType = {
    taxRate: number | null
  }

  export type BusinessSettingsMinAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
    taxRate: number | null
    currency: string | null
    receiptFooter: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessSettingsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
    taxRate: number | null
    currency: string | null
    receiptFooter: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessSettingsCountAggregateOutputType = {
    id: number
    name: number
    logo: number
    taxRate: number
    currency: number
    receiptFooter: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusinessSettingsAvgAggregateInputType = {
    taxRate?: true
  }

  export type BusinessSettingsSumAggregateInputType = {
    taxRate?: true
  }

  export type BusinessSettingsMinAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    taxRate?: true
    currency?: true
    receiptFooter?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessSettingsMaxAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    taxRate?: true
    currency?: true
    receiptFooter?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessSettingsCountAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    taxRate?: true
    currency?: true
    receiptFooter?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusinessSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessSettings to aggregate.
     */
    where?: BusinessSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessSettings to fetch.
     */
    orderBy?: BusinessSettingsOrderByWithRelationInput | BusinessSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessSettings
    **/
    _count?: true | BusinessSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessSettingsMaxAggregateInputType
  }

  export type GetBusinessSettingsAggregateType<T extends BusinessSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessSettings[P]>
      : GetScalarType<T[P], AggregateBusinessSettings[P]>
  }




  export type BusinessSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessSettingsWhereInput
    orderBy?: BusinessSettingsOrderByWithAggregationInput | BusinessSettingsOrderByWithAggregationInput[]
    by: BusinessSettingsScalarFieldEnum[] | BusinessSettingsScalarFieldEnum
    having?: BusinessSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessSettingsCountAggregateInputType | true
    _avg?: BusinessSettingsAvgAggregateInputType
    _sum?: BusinessSettingsSumAggregateInputType
    _min?: BusinessSettingsMinAggregateInputType
    _max?: BusinessSettingsMaxAggregateInputType
  }

  export type BusinessSettingsGroupByOutputType = {
    id: string
    name: string
    logo: string | null
    taxRate: number
    currency: string
    receiptFooter: string | null
    createdAt: Date
    updatedAt: Date
    _count: BusinessSettingsCountAggregateOutputType | null
    _avg: BusinessSettingsAvgAggregateOutputType | null
    _sum: BusinessSettingsSumAggregateOutputType | null
    _min: BusinessSettingsMinAggregateOutputType | null
    _max: BusinessSettingsMaxAggregateOutputType | null
  }

  type GetBusinessSettingsGroupByPayload<T extends BusinessSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessSettingsGroupByOutputType[P]>
        }
      >
    >


  export type BusinessSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    taxRate?: boolean
    currency?: boolean
    receiptFooter?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["businessSettings"]>

  export type BusinessSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    taxRate?: boolean
    currency?: boolean
    receiptFooter?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["businessSettings"]>

  export type BusinessSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    taxRate?: boolean
    currency?: boolean
    receiptFooter?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["businessSettings"]>

  export type BusinessSettingsSelectScalar = {
    id?: boolean
    name?: boolean
    logo?: boolean
    taxRate?: boolean
    currency?: boolean
    receiptFooter?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusinessSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "logo" | "taxRate" | "currency" | "receiptFooter" | "createdAt" | "updatedAt", ExtArgs["result"]["businessSettings"]>

  export type $BusinessSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      logo: string | null
      taxRate: number
      currency: string
      receiptFooter: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["businessSettings"]>
    composites: {}
  }

  type BusinessSettingsGetPayload<S extends boolean | null | undefined | BusinessSettingsDefaultArgs> = $Result.GetResult<Prisma.$BusinessSettingsPayload, S>

  type BusinessSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BusinessSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BusinessSettingsCountAggregateInputType | true
    }

  export interface BusinessSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessSettings'], meta: { name: 'BusinessSettings' } }
    /**
     * Find zero or one BusinessSettings that matches the filter.
     * @param {BusinessSettingsFindUniqueArgs} args - Arguments to find a BusinessSettings
     * @example
     * // Get one BusinessSettings
     * const businessSettings = await prisma.businessSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessSettingsFindUniqueArgs>(args: SelectSubset<T, BusinessSettingsFindUniqueArgs<ExtArgs>>): Prisma__BusinessSettingsClient<$Result.GetResult<Prisma.$BusinessSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BusinessSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BusinessSettingsFindUniqueOrThrowArgs} args - Arguments to find a BusinessSettings
     * @example
     * // Get one BusinessSettings
     * const businessSettings = await prisma.businessSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessSettingsClient<$Result.GetResult<Prisma.$BusinessSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSettingsFindFirstArgs} args - Arguments to find a BusinessSettings
     * @example
     * // Get one BusinessSettings
     * const businessSettings = await prisma.businessSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessSettingsFindFirstArgs>(args?: SelectSubset<T, BusinessSettingsFindFirstArgs<ExtArgs>>): Prisma__BusinessSettingsClient<$Result.GetResult<Prisma.$BusinessSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSettingsFindFirstOrThrowArgs} args - Arguments to find a BusinessSettings
     * @example
     * // Get one BusinessSettings
     * const businessSettings = await prisma.businessSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessSettingsClient<$Result.GetResult<Prisma.$BusinessSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BusinessSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessSettings
     * const businessSettings = await prisma.businessSettings.findMany()
     * 
     * // Get first 10 BusinessSettings
     * const businessSettings = await prisma.businessSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessSettingsWithIdOnly = await prisma.businessSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessSettingsFindManyArgs>(args?: SelectSubset<T, BusinessSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BusinessSettings.
     * @param {BusinessSettingsCreateArgs} args - Arguments to create a BusinessSettings.
     * @example
     * // Create one BusinessSettings
     * const BusinessSettings = await prisma.businessSettings.create({
     *   data: {
     *     // ... data to create a BusinessSettings
     *   }
     * })
     * 
     */
    create<T extends BusinessSettingsCreateArgs>(args: SelectSubset<T, BusinessSettingsCreateArgs<ExtArgs>>): Prisma__BusinessSettingsClient<$Result.GetResult<Prisma.$BusinessSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BusinessSettings.
     * @param {BusinessSettingsCreateManyArgs} args - Arguments to create many BusinessSettings.
     * @example
     * // Create many BusinessSettings
     * const businessSettings = await prisma.businessSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessSettingsCreateManyArgs>(args?: SelectSubset<T, BusinessSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessSettings and returns the data saved in the database.
     * @param {BusinessSettingsCreateManyAndReturnArgs} args - Arguments to create many BusinessSettings.
     * @example
     * // Create many BusinessSettings
     * const businessSettings = await prisma.businessSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessSettings and only return the `id`
     * const businessSettingsWithIdOnly = await prisma.businessSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BusinessSettings.
     * @param {BusinessSettingsDeleteArgs} args - Arguments to delete one BusinessSettings.
     * @example
     * // Delete one BusinessSettings
     * const BusinessSettings = await prisma.businessSettings.delete({
     *   where: {
     *     // ... filter to delete one BusinessSettings
     *   }
     * })
     * 
     */
    delete<T extends BusinessSettingsDeleteArgs>(args: SelectSubset<T, BusinessSettingsDeleteArgs<ExtArgs>>): Prisma__BusinessSettingsClient<$Result.GetResult<Prisma.$BusinessSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BusinessSettings.
     * @param {BusinessSettingsUpdateArgs} args - Arguments to update one BusinessSettings.
     * @example
     * // Update one BusinessSettings
     * const businessSettings = await prisma.businessSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessSettingsUpdateArgs>(args: SelectSubset<T, BusinessSettingsUpdateArgs<ExtArgs>>): Prisma__BusinessSettingsClient<$Result.GetResult<Prisma.$BusinessSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BusinessSettings.
     * @param {BusinessSettingsDeleteManyArgs} args - Arguments to filter BusinessSettings to delete.
     * @example
     * // Delete a few BusinessSettings
     * const { count } = await prisma.businessSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessSettingsDeleteManyArgs>(args?: SelectSubset<T, BusinessSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessSettings
     * const businessSettings = await prisma.businessSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessSettingsUpdateManyArgs>(args: SelectSubset<T, BusinessSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessSettings and returns the data updated in the database.
     * @param {BusinessSettingsUpdateManyAndReturnArgs} args - Arguments to update many BusinessSettings.
     * @example
     * // Update many BusinessSettings
     * const businessSettings = await prisma.businessSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BusinessSettings and only return the `id`
     * const businessSettingsWithIdOnly = await prisma.businessSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BusinessSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, BusinessSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BusinessSettings.
     * @param {BusinessSettingsUpsertArgs} args - Arguments to update or create a BusinessSettings.
     * @example
     * // Update or create a BusinessSettings
     * const businessSettings = await prisma.businessSettings.upsert({
     *   create: {
     *     // ... data to create a BusinessSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessSettings we want to update
     *   }
     * })
     */
    upsert<T extends BusinessSettingsUpsertArgs>(args: SelectSubset<T, BusinessSettingsUpsertArgs<ExtArgs>>): Prisma__BusinessSettingsClient<$Result.GetResult<Prisma.$BusinessSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BusinessSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSettingsCountArgs} args - Arguments to filter BusinessSettings to count.
     * @example
     * // Count the number of BusinessSettings
     * const count = await prisma.businessSettings.count({
     *   where: {
     *     // ... the filter for the BusinessSettings we want to count
     *   }
     * })
    **/
    count<T extends BusinessSettingsCountArgs>(
      args?: Subset<T, BusinessSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessSettingsAggregateArgs>(args: Subset<T, BusinessSettingsAggregateArgs>): Prisma.PrismaPromise<GetBusinessSettingsAggregateType<T>>

    /**
     * Group by BusinessSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessSettingsGroupByArgs['orderBy'] }
        : { orderBy?: BusinessSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessSettings model
   */
  readonly fields: BusinessSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessSettings model
   */
  interface BusinessSettingsFieldRefs {
    readonly id: FieldRef<"BusinessSettings", 'String'>
    readonly name: FieldRef<"BusinessSettings", 'String'>
    readonly logo: FieldRef<"BusinessSettings", 'String'>
    readonly taxRate: FieldRef<"BusinessSettings", 'Float'>
    readonly currency: FieldRef<"BusinessSettings", 'String'>
    readonly receiptFooter: FieldRef<"BusinessSettings", 'String'>
    readonly createdAt: FieldRef<"BusinessSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessSettings findUnique
   */
  export type BusinessSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSettings
     */
    select?: BusinessSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessSettings
     */
    omit?: BusinessSettingsOmit<ExtArgs> | null
    /**
     * Filter, which BusinessSettings to fetch.
     */
    where: BusinessSettingsWhereUniqueInput
  }

  /**
   * BusinessSettings findUniqueOrThrow
   */
  export type BusinessSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSettings
     */
    select?: BusinessSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessSettings
     */
    omit?: BusinessSettingsOmit<ExtArgs> | null
    /**
     * Filter, which BusinessSettings to fetch.
     */
    where: BusinessSettingsWhereUniqueInput
  }

  /**
   * BusinessSettings findFirst
   */
  export type BusinessSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSettings
     */
    select?: BusinessSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessSettings
     */
    omit?: BusinessSettingsOmit<ExtArgs> | null
    /**
     * Filter, which BusinessSettings to fetch.
     */
    where?: BusinessSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessSettings to fetch.
     */
    orderBy?: BusinessSettingsOrderByWithRelationInput | BusinessSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessSettings.
     */
    cursor?: BusinessSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessSettings.
     */
    distinct?: BusinessSettingsScalarFieldEnum | BusinessSettingsScalarFieldEnum[]
  }

  /**
   * BusinessSettings findFirstOrThrow
   */
  export type BusinessSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSettings
     */
    select?: BusinessSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessSettings
     */
    omit?: BusinessSettingsOmit<ExtArgs> | null
    /**
     * Filter, which BusinessSettings to fetch.
     */
    where?: BusinessSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessSettings to fetch.
     */
    orderBy?: BusinessSettingsOrderByWithRelationInput | BusinessSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessSettings.
     */
    cursor?: BusinessSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessSettings.
     */
    distinct?: BusinessSettingsScalarFieldEnum | BusinessSettingsScalarFieldEnum[]
  }

  /**
   * BusinessSettings findMany
   */
  export type BusinessSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSettings
     */
    select?: BusinessSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessSettings
     */
    omit?: BusinessSettingsOmit<ExtArgs> | null
    /**
     * Filter, which BusinessSettings to fetch.
     */
    where?: BusinessSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessSettings to fetch.
     */
    orderBy?: BusinessSettingsOrderByWithRelationInput | BusinessSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessSettings.
     */
    cursor?: BusinessSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessSettings.
     */
    skip?: number
    distinct?: BusinessSettingsScalarFieldEnum | BusinessSettingsScalarFieldEnum[]
  }

  /**
   * BusinessSettings create
   */
  export type BusinessSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSettings
     */
    select?: BusinessSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessSettings
     */
    omit?: BusinessSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a BusinessSettings.
     */
    data: XOR<BusinessSettingsCreateInput, BusinessSettingsUncheckedCreateInput>
  }

  /**
   * BusinessSettings createMany
   */
  export type BusinessSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessSettings.
     */
    data: BusinessSettingsCreateManyInput | BusinessSettingsCreateManyInput[]
  }

  /**
   * BusinessSettings createManyAndReturn
   */
  export type BusinessSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSettings
     */
    select?: BusinessSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessSettings
     */
    omit?: BusinessSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many BusinessSettings.
     */
    data: BusinessSettingsCreateManyInput | BusinessSettingsCreateManyInput[]
  }

  /**
   * BusinessSettings update
   */
  export type BusinessSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSettings
     */
    select?: BusinessSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessSettings
     */
    omit?: BusinessSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a BusinessSettings.
     */
    data: XOR<BusinessSettingsUpdateInput, BusinessSettingsUncheckedUpdateInput>
    /**
     * Choose, which BusinessSettings to update.
     */
    where: BusinessSettingsWhereUniqueInput
  }

  /**
   * BusinessSettings updateMany
   */
  export type BusinessSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessSettings.
     */
    data: XOR<BusinessSettingsUpdateManyMutationInput, BusinessSettingsUncheckedUpdateManyInput>
    /**
     * Filter which BusinessSettings to update
     */
    where?: BusinessSettingsWhereInput
    /**
     * Limit how many BusinessSettings to update.
     */
    limit?: number
  }

  /**
   * BusinessSettings updateManyAndReturn
   */
  export type BusinessSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSettings
     */
    select?: BusinessSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessSettings
     */
    omit?: BusinessSettingsOmit<ExtArgs> | null
    /**
     * The data used to update BusinessSettings.
     */
    data: XOR<BusinessSettingsUpdateManyMutationInput, BusinessSettingsUncheckedUpdateManyInput>
    /**
     * Filter which BusinessSettings to update
     */
    where?: BusinessSettingsWhereInput
    /**
     * Limit how many BusinessSettings to update.
     */
    limit?: number
  }

  /**
   * BusinessSettings upsert
   */
  export type BusinessSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSettings
     */
    select?: BusinessSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessSettings
     */
    omit?: BusinessSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the BusinessSettings to update in case it exists.
     */
    where: BusinessSettingsWhereUniqueInput
    /**
     * In case the BusinessSettings found by the `where` argument doesn't exist, create a new BusinessSettings with this data.
     */
    create: XOR<BusinessSettingsCreateInput, BusinessSettingsUncheckedCreateInput>
    /**
     * In case the BusinessSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessSettingsUpdateInput, BusinessSettingsUncheckedUpdateInput>
  }

  /**
   * BusinessSettings delete
   */
  export type BusinessSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSettings
     */
    select?: BusinessSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessSettings
     */
    omit?: BusinessSettingsOmit<ExtArgs> | null
    /**
     * Filter which BusinessSettings to delete.
     */
    where: BusinessSettingsWhereUniqueInput
  }

  /**
   * BusinessSettings deleteMany
   */
  export type BusinessSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessSettings to delete
     */
    where?: BusinessSettingsWhereInput
    /**
     * Limit how many BusinessSettings to delete.
     */
    limit?: number
  }

  /**
   * BusinessSettings without action
   */
  export type BusinessSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessSettings
     */
    select?: BusinessSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessSettings
     */
    omit?: BusinessSettingsOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    email: 'email',
    loyaltyPoints: 'loyaltyPoints',
    loyaltyTier: 'loyaltyTier',
    referralCode: 'referralCode',
    referredBy: 'referredBy',
    preferences: 'preferences',
    createdAt: 'createdAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const WashServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    duration: 'duration',
    createdAt: 'createdAt'
  };

  export type WashServiceScalarFieldEnum = (typeof WashServiceScalarFieldEnum)[keyof typeof WashServiceScalarFieldEnum]


  export const WashTransactionScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    customerId: 'customerId',
    quantity: 'quantity',
    total: 'total',
    paymentMethod: 'paymentMethod',
    vehicleType: 'vehicleType',
    discount: 'discount',
    promoCodeId: 'promoCodeId',
    receiptNumber: 'receiptNumber',
    createdAt: 'createdAt'
  };

  export type WashTransactionScalarFieldEnum = (typeof WashTransactionScalarFieldEnum)[keyof typeof WashTransactionScalarFieldEnum]


  export const PromoCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    discount: 'discount',
    type: 'type',
    expiry: 'expiry',
    usageLimit: 'usageLimit',
    usageCount: 'usageCount',
    createdAt: 'createdAt'
  };

  export type PromoCodeScalarFieldEnum = (typeof PromoCodeScalarFieldEnum)[keyof typeof PromoCodeScalarFieldEnum]


  export const InventoryItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    quantity: 'quantity',
    minStock: 'minStock',
    unit: 'unit',
    supplier: 'supplier',
    costPrice: 'costPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


  export const InventoryUsageScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    quantity: 'quantity',
    reason: 'reason',
    transactionId: 'transactionId',
    createdAt: 'createdAt'
  };

  export type InventoryUsageScalarFieldEnum = (typeof InventoryUsageScalarFieldEnum)[keyof typeof InventoryUsageScalarFieldEnum]


  export const StaffScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    role: 'role',
    password: 'password',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type StaffScalarFieldEnum = (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum]


  export const StaffShiftScalarFieldEnum: {
    id: 'id',
    staffId: 'staffId',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt'
  };

  export type StaffShiftScalarFieldEnum = (typeof StaffShiftScalarFieldEnum)[keyof typeof StaffShiftScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    staffId: 'staffId',
    action: 'action',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const BusinessSettingsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    logo: 'logo',
    taxRate: 'taxRate',
    currency: 'currency',
    receiptFooter: 'receiptFooter',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusinessSettingsScalarFieldEnum = (typeof BusinessSettingsScalarFieldEnum)[keyof typeof BusinessSettingsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    loyaltyPoints?: IntFilter<"Customer"> | number
    loyaltyTier?: StringFilter<"Customer"> | string
    referralCode?: StringNullableFilter<"Customer"> | string | null
    referredBy?: StringNullableFilter<"Customer"> | string | null
    preferences?: JsonNullableFilter<"Customer">
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    transactions?: WashTransactionListRelationFilter
    referrals?: CustomerListRelationFilter
    referrer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    loyaltyPoints?: SortOrder
    loyaltyTier?: SortOrder
    referralCode?: SortOrderInput | SortOrder
    referredBy?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    transactions?: WashTransactionOrderByRelationAggregateInput
    referrals?: CustomerOrderByRelationAggregateInput
    referrer?: CustomerOrderByWithRelationInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    referralCode?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    loyaltyPoints?: IntFilter<"Customer"> | number
    loyaltyTier?: StringFilter<"Customer"> | string
    referredBy?: StringNullableFilter<"Customer"> | string | null
    preferences?: JsonNullableFilter<"Customer">
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    transactions?: WashTransactionListRelationFilter
    referrals?: CustomerListRelationFilter
    referrer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }, "id" | "referralCode">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    loyaltyPoints?: SortOrder
    loyaltyTier?: SortOrder
    referralCode?: SortOrderInput | SortOrder
    referredBy?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    loyaltyPoints?: IntWithAggregatesFilter<"Customer"> | number
    loyaltyTier?: StringWithAggregatesFilter<"Customer"> | string
    referralCode?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    referredBy?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    preferences?: JsonNullableWithAggregatesFilter<"Customer">
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type WashServiceWhereInput = {
    AND?: WashServiceWhereInput | WashServiceWhereInput[]
    OR?: WashServiceWhereInput[]
    NOT?: WashServiceWhereInput | WashServiceWhereInput[]
    id?: StringFilter<"WashService"> | string
    name?: StringFilter<"WashService"> | string
    price?: FloatFilter<"WashService"> | number
    duration?: IntFilter<"WashService"> | number
    createdAt?: DateTimeFilter<"WashService"> | Date | string
    transactions?: WashTransactionListRelationFilter
  }

  export type WashServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    transactions?: WashTransactionOrderByRelationAggregateInput
  }

  export type WashServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WashServiceWhereInput | WashServiceWhereInput[]
    OR?: WashServiceWhereInput[]
    NOT?: WashServiceWhereInput | WashServiceWhereInput[]
    name?: StringFilter<"WashService"> | string
    price?: FloatFilter<"WashService"> | number
    duration?: IntFilter<"WashService"> | number
    createdAt?: DateTimeFilter<"WashService"> | Date | string
    transactions?: WashTransactionListRelationFilter
  }, "id">

  export type WashServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    _count?: WashServiceCountOrderByAggregateInput
    _avg?: WashServiceAvgOrderByAggregateInput
    _max?: WashServiceMaxOrderByAggregateInput
    _min?: WashServiceMinOrderByAggregateInput
    _sum?: WashServiceSumOrderByAggregateInput
  }

  export type WashServiceScalarWhereWithAggregatesInput = {
    AND?: WashServiceScalarWhereWithAggregatesInput | WashServiceScalarWhereWithAggregatesInput[]
    OR?: WashServiceScalarWhereWithAggregatesInput[]
    NOT?: WashServiceScalarWhereWithAggregatesInput | WashServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WashService"> | string
    name?: StringWithAggregatesFilter<"WashService"> | string
    price?: FloatWithAggregatesFilter<"WashService"> | number
    duration?: IntWithAggregatesFilter<"WashService"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WashService"> | Date | string
  }

  export type WashTransactionWhereInput = {
    AND?: WashTransactionWhereInput | WashTransactionWhereInput[]
    OR?: WashTransactionWhereInput[]
    NOT?: WashTransactionWhereInput | WashTransactionWhereInput[]
    id?: StringFilter<"WashTransaction"> | string
    serviceId?: StringFilter<"WashTransaction"> | string
    customerId?: StringNullableFilter<"WashTransaction"> | string | null
    quantity?: IntFilter<"WashTransaction"> | number
    total?: FloatFilter<"WashTransaction"> | number
    paymentMethod?: StringNullableFilter<"WashTransaction"> | string | null
    vehicleType?: StringNullableFilter<"WashTransaction"> | string | null
    discount?: FloatNullableFilter<"WashTransaction"> | number | null
    promoCodeId?: StringNullableFilter<"WashTransaction"> | string | null
    receiptNumber?: StringNullableFilter<"WashTransaction"> | string | null
    createdAt?: DateTimeFilter<"WashTransaction"> | Date | string
    service?: XOR<WashServiceScalarRelationFilter, WashServiceWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    promoCode?: XOR<PromoCodeNullableScalarRelationFilter, PromoCodeWhereInput> | null
  }

  export type WashTransactionOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    vehicleType?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    promoCodeId?: SortOrderInput | SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    service?: WashServiceOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    promoCode?: PromoCodeOrderByWithRelationInput
  }

  export type WashTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    receiptNumber?: string
    AND?: WashTransactionWhereInput | WashTransactionWhereInput[]
    OR?: WashTransactionWhereInput[]
    NOT?: WashTransactionWhereInput | WashTransactionWhereInput[]
    serviceId?: StringFilter<"WashTransaction"> | string
    customerId?: StringNullableFilter<"WashTransaction"> | string | null
    quantity?: IntFilter<"WashTransaction"> | number
    total?: FloatFilter<"WashTransaction"> | number
    paymentMethod?: StringNullableFilter<"WashTransaction"> | string | null
    vehicleType?: StringNullableFilter<"WashTransaction"> | string | null
    discount?: FloatNullableFilter<"WashTransaction"> | number | null
    promoCodeId?: StringNullableFilter<"WashTransaction"> | string | null
    createdAt?: DateTimeFilter<"WashTransaction"> | Date | string
    service?: XOR<WashServiceScalarRelationFilter, WashServiceWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    promoCode?: XOR<PromoCodeNullableScalarRelationFilter, PromoCodeWhereInput> | null
  }, "id" | "receiptNumber">

  export type WashTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    vehicleType?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    promoCodeId?: SortOrderInput | SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WashTransactionCountOrderByAggregateInput
    _avg?: WashTransactionAvgOrderByAggregateInput
    _max?: WashTransactionMaxOrderByAggregateInput
    _min?: WashTransactionMinOrderByAggregateInput
    _sum?: WashTransactionSumOrderByAggregateInput
  }

  export type WashTransactionScalarWhereWithAggregatesInput = {
    AND?: WashTransactionScalarWhereWithAggregatesInput | WashTransactionScalarWhereWithAggregatesInput[]
    OR?: WashTransactionScalarWhereWithAggregatesInput[]
    NOT?: WashTransactionScalarWhereWithAggregatesInput | WashTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WashTransaction"> | string
    serviceId?: StringWithAggregatesFilter<"WashTransaction"> | string
    customerId?: StringNullableWithAggregatesFilter<"WashTransaction"> | string | null
    quantity?: IntWithAggregatesFilter<"WashTransaction"> | number
    total?: FloatWithAggregatesFilter<"WashTransaction"> | number
    paymentMethod?: StringNullableWithAggregatesFilter<"WashTransaction"> | string | null
    vehicleType?: StringNullableWithAggregatesFilter<"WashTransaction"> | string | null
    discount?: FloatNullableWithAggregatesFilter<"WashTransaction"> | number | null
    promoCodeId?: StringNullableWithAggregatesFilter<"WashTransaction"> | string | null
    receiptNumber?: StringNullableWithAggregatesFilter<"WashTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WashTransaction"> | Date | string
  }

  export type PromoCodeWhereInput = {
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[]
    OR?: PromoCodeWhereInput[]
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[]
    id?: StringFilter<"PromoCode"> | string
    code?: StringFilter<"PromoCode"> | string
    discount?: FloatFilter<"PromoCode"> | number
    type?: StringFilter<"PromoCode"> | string
    expiry?: DateTimeNullableFilter<"PromoCode"> | Date | string | null
    usageLimit?: IntNullableFilter<"PromoCode"> | number | null
    usageCount?: IntFilter<"PromoCode"> | number
    createdAt?: DateTimeFilter<"PromoCode"> | Date | string
    transactions?: WashTransactionListRelationFilter
  }

  export type PromoCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    discount?: SortOrder
    type?: SortOrder
    expiry?: SortOrderInput | SortOrder
    usageLimit?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    transactions?: WashTransactionOrderByRelationAggregateInput
  }

  export type PromoCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[]
    OR?: PromoCodeWhereInput[]
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[]
    discount?: FloatFilter<"PromoCode"> | number
    type?: StringFilter<"PromoCode"> | string
    expiry?: DateTimeNullableFilter<"PromoCode"> | Date | string | null
    usageLimit?: IntNullableFilter<"PromoCode"> | number | null
    usageCount?: IntFilter<"PromoCode"> | number
    createdAt?: DateTimeFilter<"PromoCode"> | Date | string
    transactions?: WashTransactionListRelationFilter
  }, "id" | "code">

  export type PromoCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    discount?: SortOrder
    type?: SortOrder
    expiry?: SortOrderInput | SortOrder
    usageLimit?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    _count?: PromoCodeCountOrderByAggregateInput
    _avg?: PromoCodeAvgOrderByAggregateInput
    _max?: PromoCodeMaxOrderByAggregateInput
    _min?: PromoCodeMinOrderByAggregateInput
    _sum?: PromoCodeSumOrderByAggregateInput
  }

  export type PromoCodeScalarWhereWithAggregatesInput = {
    AND?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[]
    OR?: PromoCodeScalarWhereWithAggregatesInput[]
    NOT?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromoCode"> | string
    code?: StringWithAggregatesFilter<"PromoCode"> | string
    discount?: FloatWithAggregatesFilter<"PromoCode"> | number
    type?: StringWithAggregatesFilter<"PromoCode"> | string
    expiry?: DateTimeNullableWithAggregatesFilter<"PromoCode"> | Date | string | null
    usageLimit?: IntNullableWithAggregatesFilter<"PromoCode"> | number | null
    usageCount?: IntWithAggregatesFilter<"PromoCode"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PromoCode"> | Date | string
  }

  export type InventoryItemWhereInput = {
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    name?: StringFilter<"InventoryItem"> | string
    description?: StringNullableFilter<"InventoryItem"> | string | null
    quantity?: IntFilter<"InventoryItem"> | number
    minStock?: IntFilter<"InventoryItem"> | number
    unit?: StringFilter<"InventoryItem"> | string
    supplier?: StringNullableFilter<"InventoryItem"> | string | null
    costPrice?: FloatNullableFilter<"InventoryItem"> | number | null
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    usages?: InventoryUsageListRelationFilter
  }

  export type InventoryItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    minStock?: SortOrder
    unit?: SortOrder
    supplier?: SortOrderInput | SortOrder
    costPrice?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usages?: InventoryUsageOrderByRelationAggregateInput
  }

  export type InventoryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    name?: StringFilter<"InventoryItem"> | string
    description?: StringNullableFilter<"InventoryItem"> | string | null
    quantity?: IntFilter<"InventoryItem"> | number
    minStock?: IntFilter<"InventoryItem"> | number
    unit?: StringFilter<"InventoryItem"> | string
    supplier?: StringNullableFilter<"InventoryItem"> | string | null
    costPrice?: FloatNullableFilter<"InventoryItem"> | number | null
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    usages?: InventoryUsageListRelationFilter
  }, "id">

  export type InventoryItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    minStock?: SortOrder
    unit?: SortOrder
    supplier?: SortOrderInput | SortOrder
    costPrice?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryItemCountOrderByAggregateInput
    _avg?: InventoryItemAvgOrderByAggregateInput
    _max?: InventoryItemMaxOrderByAggregateInput
    _min?: InventoryItemMinOrderByAggregateInput
    _sum?: InventoryItemSumOrderByAggregateInput
  }

  export type InventoryItemScalarWhereWithAggregatesInput = {
    AND?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    OR?: InventoryItemScalarWhereWithAggregatesInput[]
    NOT?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryItem"> | string
    name?: StringWithAggregatesFilter<"InventoryItem"> | string
    description?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    quantity?: IntWithAggregatesFilter<"InventoryItem"> | number
    minStock?: IntWithAggregatesFilter<"InventoryItem"> | number
    unit?: StringWithAggregatesFilter<"InventoryItem"> | string
    supplier?: StringNullableWithAggregatesFilter<"InventoryItem"> | string | null
    costPrice?: FloatNullableWithAggregatesFilter<"InventoryItem"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
  }

  export type InventoryUsageWhereInput = {
    AND?: InventoryUsageWhereInput | InventoryUsageWhereInput[]
    OR?: InventoryUsageWhereInput[]
    NOT?: InventoryUsageWhereInput | InventoryUsageWhereInput[]
    id?: StringFilter<"InventoryUsage"> | string
    itemId?: StringFilter<"InventoryUsage"> | string
    quantity?: IntFilter<"InventoryUsage"> | number
    reason?: StringFilter<"InventoryUsage"> | string
    transactionId?: StringNullableFilter<"InventoryUsage"> | string | null
    createdAt?: DateTimeFilter<"InventoryUsage"> | Date | string
    item?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
  }

  export type InventoryUsageOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    item?: InventoryItemOrderByWithRelationInput
  }

  export type InventoryUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryUsageWhereInput | InventoryUsageWhereInput[]
    OR?: InventoryUsageWhereInput[]
    NOT?: InventoryUsageWhereInput | InventoryUsageWhereInput[]
    itemId?: StringFilter<"InventoryUsage"> | string
    quantity?: IntFilter<"InventoryUsage"> | number
    reason?: StringFilter<"InventoryUsage"> | string
    transactionId?: StringNullableFilter<"InventoryUsage"> | string | null
    createdAt?: DateTimeFilter<"InventoryUsage"> | Date | string
    item?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
  }, "id">

  export type InventoryUsageOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InventoryUsageCountOrderByAggregateInput
    _avg?: InventoryUsageAvgOrderByAggregateInput
    _max?: InventoryUsageMaxOrderByAggregateInput
    _min?: InventoryUsageMinOrderByAggregateInput
    _sum?: InventoryUsageSumOrderByAggregateInput
  }

  export type InventoryUsageScalarWhereWithAggregatesInput = {
    AND?: InventoryUsageScalarWhereWithAggregatesInput | InventoryUsageScalarWhereWithAggregatesInput[]
    OR?: InventoryUsageScalarWhereWithAggregatesInput[]
    NOT?: InventoryUsageScalarWhereWithAggregatesInput | InventoryUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryUsage"> | string
    itemId?: StringWithAggregatesFilter<"InventoryUsage"> | string
    quantity?: IntWithAggregatesFilter<"InventoryUsage"> | number
    reason?: StringWithAggregatesFilter<"InventoryUsage"> | string
    transactionId?: StringNullableWithAggregatesFilter<"InventoryUsage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InventoryUsage"> | Date | string
  }

  export type StaffWhereInput = {
    AND?: StaffWhereInput | StaffWhereInput[]
    OR?: StaffWhereInput[]
    NOT?: StaffWhereInput | StaffWhereInput[]
    id?: StringFilter<"Staff"> | string
    name?: StringFilter<"Staff"> | string
    email?: StringFilter<"Staff"> | string
    role?: StringFilter<"Staff"> | string
    password?: StringFilter<"Staff"> | string
    isActive?: BoolFilter<"Staff"> | boolean
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    shifts?: StaffShiftListRelationFilter
    audits?: AuditLogListRelationFilter
  }

  export type StaffOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    shifts?: StaffShiftOrderByRelationAggregateInput
    audits?: AuditLogOrderByRelationAggregateInput
  }

  export type StaffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: StaffWhereInput | StaffWhereInput[]
    OR?: StaffWhereInput[]
    NOT?: StaffWhereInput | StaffWhereInput[]
    name?: StringFilter<"Staff"> | string
    role?: StringFilter<"Staff"> | string
    password?: StringFilter<"Staff"> | string
    isActive?: BoolFilter<"Staff"> | boolean
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    shifts?: StaffShiftListRelationFilter
    audits?: AuditLogListRelationFilter
  }, "id" | "email">

  export type StaffOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: StaffCountOrderByAggregateInput
    _max?: StaffMaxOrderByAggregateInput
    _min?: StaffMinOrderByAggregateInput
  }

  export type StaffScalarWhereWithAggregatesInput = {
    AND?: StaffScalarWhereWithAggregatesInput | StaffScalarWhereWithAggregatesInput[]
    OR?: StaffScalarWhereWithAggregatesInput[]
    NOT?: StaffScalarWhereWithAggregatesInput | StaffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Staff"> | string
    name?: StringWithAggregatesFilter<"Staff"> | string
    email?: StringWithAggregatesFilter<"Staff"> | string
    role?: StringWithAggregatesFilter<"Staff"> | string
    password?: StringWithAggregatesFilter<"Staff"> | string
    isActive?: BoolWithAggregatesFilter<"Staff"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
  }

  export type StaffShiftWhereInput = {
    AND?: StaffShiftWhereInput | StaffShiftWhereInput[]
    OR?: StaffShiftWhereInput[]
    NOT?: StaffShiftWhereInput | StaffShiftWhereInput[]
    id?: StringFilter<"StaffShift"> | string
    staffId?: StringFilter<"StaffShift"> | string
    startTime?: DateTimeFilter<"StaffShift"> | Date | string
    endTime?: DateTimeNullableFilter<"StaffShift"> | Date | string | null
    createdAt?: DateTimeFilter<"StaffShift"> | Date | string
    staff?: XOR<StaffScalarRelationFilter, StaffWhereInput>
  }

  export type StaffShiftOrderByWithRelationInput = {
    id?: SortOrder
    staffId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    staff?: StaffOrderByWithRelationInput
  }

  export type StaffShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StaffShiftWhereInput | StaffShiftWhereInput[]
    OR?: StaffShiftWhereInput[]
    NOT?: StaffShiftWhereInput | StaffShiftWhereInput[]
    staffId?: StringFilter<"StaffShift"> | string
    startTime?: DateTimeFilter<"StaffShift"> | Date | string
    endTime?: DateTimeNullableFilter<"StaffShift"> | Date | string | null
    createdAt?: DateTimeFilter<"StaffShift"> | Date | string
    staff?: XOR<StaffScalarRelationFilter, StaffWhereInput>
  }, "id">

  export type StaffShiftOrderByWithAggregationInput = {
    id?: SortOrder
    staffId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StaffShiftCountOrderByAggregateInput
    _max?: StaffShiftMaxOrderByAggregateInput
    _min?: StaffShiftMinOrderByAggregateInput
  }

  export type StaffShiftScalarWhereWithAggregatesInput = {
    AND?: StaffShiftScalarWhereWithAggregatesInput | StaffShiftScalarWhereWithAggregatesInput[]
    OR?: StaffShiftScalarWhereWithAggregatesInput[]
    NOT?: StaffShiftScalarWhereWithAggregatesInput | StaffShiftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StaffShift"> | string
    staffId?: StringWithAggregatesFilter<"StaffShift"> | string
    startTime?: DateTimeWithAggregatesFilter<"StaffShift"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"StaffShift"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StaffShift"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    staffId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    details?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    staff?: XOR<StaffScalarRelationFilter, StaffWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    staffId?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    staff?: StaffOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    staffId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    details?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    staff?: XOR<StaffScalarRelationFilter, StaffWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    staffId?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    staffId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type BusinessSettingsWhereInput = {
    AND?: BusinessSettingsWhereInput | BusinessSettingsWhereInput[]
    OR?: BusinessSettingsWhereInput[]
    NOT?: BusinessSettingsWhereInput | BusinessSettingsWhereInput[]
    id?: StringFilter<"BusinessSettings"> | string
    name?: StringFilter<"BusinessSettings"> | string
    logo?: StringNullableFilter<"BusinessSettings"> | string | null
    taxRate?: FloatFilter<"BusinessSettings"> | number
    currency?: StringFilter<"BusinessSettings"> | string
    receiptFooter?: StringNullableFilter<"BusinessSettings"> | string | null
    createdAt?: DateTimeFilter<"BusinessSettings"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessSettings"> | Date | string
  }

  export type BusinessSettingsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    taxRate?: SortOrder
    currency?: SortOrder
    receiptFooter?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BusinessSettingsWhereInput | BusinessSettingsWhereInput[]
    OR?: BusinessSettingsWhereInput[]
    NOT?: BusinessSettingsWhereInput | BusinessSettingsWhereInput[]
    name?: StringFilter<"BusinessSettings"> | string
    logo?: StringNullableFilter<"BusinessSettings"> | string | null
    taxRate?: FloatFilter<"BusinessSettings"> | number
    currency?: StringFilter<"BusinessSettings"> | string
    receiptFooter?: StringNullableFilter<"BusinessSettings"> | string | null
    createdAt?: DateTimeFilter<"BusinessSettings"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessSettings"> | Date | string
  }, "id">

  export type BusinessSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    taxRate?: SortOrder
    currency?: SortOrder
    receiptFooter?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusinessSettingsCountOrderByAggregateInput
    _avg?: BusinessSettingsAvgOrderByAggregateInput
    _max?: BusinessSettingsMaxOrderByAggregateInput
    _min?: BusinessSettingsMinOrderByAggregateInput
    _sum?: BusinessSettingsSumOrderByAggregateInput
  }

  export type BusinessSettingsScalarWhereWithAggregatesInput = {
    AND?: BusinessSettingsScalarWhereWithAggregatesInput | BusinessSettingsScalarWhereWithAggregatesInput[]
    OR?: BusinessSettingsScalarWhereWithAggregatesInput[]
    NOT?: BusinessSettingsScalarWhereWithAggregatesInput | BusinessSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessSettings"> | string
    name?: StringWithAggregatesFilter<"BusinessSettings"> | string
    logo?: StringNullableWithAggregatesFilter<"BusinessSettings"> | string | null
    taxRate?: FloatWithAggregatesFilter<"BusinessSettings"> | number
    currency?: StringWithAggregatesFilter<"BusinessSettings"> | string
    receiptFooter?: StringNullableWithAggregatesFilter<"BusinessSettings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BusinessSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessSettings"> | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    loyaltyPoints?: number
    loyaltyTier?: string
    referralCode?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    transactions?: WashTransactionCreateNestedManyWithoutCustomerInput
    referrals?: CustomerCreateNestedManyWithoutReferrerInput
    referrer?: CustomerCreateNestedOneWithoutReferralsInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    loyaltyPoints?: number
    loyaltyTier?: string
    referralCode?: string | null
    referredBy?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    transactions?: WashTransactionUncheckedCreateNestedManyWithoutCustomerInput
    referrals?: CustomerUncheckedCreateNestedManyWithoutReferrerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WashTransactionUpdateManyWithoutCustomerNestedInput
    referrals?: CustomerUpdateManyWithoutReferrerNestedInput
    referrer?: CustomerUpdateOneWithoutReferralsNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WashTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    referrals?: CustomerUncheckedUpdateManyWithoutReferrerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    loyaltyPoints?: number
    loyaltyTier?: string
    referralCode?: string | null
    referredBy?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashServiceCreateInput = {
    id?: string
    name: string
    price: number
    duration: number
    createdAt?: Date | string
    transactions?: WashTransactionCreateNestedManyWithoutServiceInput
  }

  export type WashServiceUncheckedCreateInput = {
    id?: string
    name: string
    price: number
    duration: number
    createdAt?: Date | string
    transactions?: WashTransactionUncheckedCreateNestedManyWithoutServiceInput
  }

  export type WashServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WashTransactionUpdateManyWithoutServiceNestedInput
  }

  export type WashServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WashTransactionUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type WashServiceCreateManyInput = {
    id?: string
    name: string
    price: number
    duration: number
    createdAt?: Date | string
  }

  export type WashServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashTransactionCreateInput = {
    id?: string
    quantity: number
    total: number
    paymentMethod?: string | null
    vehicleType?: string | null
    discount?: number | null
    receiptNumber?: string | null
    createdAt?: Date | string
    service: WashServiceCreateNestedOneWithoutTransactionsInput
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    promoCode?: PromoCodeCreateNestedOneWithoutTransactionsInput
  }

  export type WashTransactionUncheckedCreateInput = {
    id?: string
    serviceId: string
    customerId?: string | null
    quantity: number
    total: number
    paymentMethod?: string | null
    vehicleType?: string | null
    discount?: number | null
    promoCodeId?: string | null
    receiptNumber?: string | null
    createdAt?: Date | string
  }

  export type WashTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: WashServiceUpdateOneRequiredWithoutTransactionsNestedInput
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    promoCode?: PromoCodeUpdateOneWithoutTransactionsNestedInput
  }

  export type WashTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashTransactionCreateManyInput = {
    id?: string
    serviceId: string
    customerId?: string | null
    quantity: number
    total: number
    paymentMethod?: string | null
    vehicleType?: string | null
    discount?: number | null
    promoCodeId?: string | null
    receiptNumber?: string | null
    createdAt?: Date | string
  }

  export type WashTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeCreateInput = {
    id?: string
    code: string
    discount: number
    type: string
    expiry?: Date | string | null
    usageLimit?: number | null
    usageCount?: number
    createdAt?: Date | string
    transactions?: WashTransactionCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeUncheckedCreateInput = {
    id?: string
    code: string
    discount: number
    type: string
    expiry?: Date | string | null
    usageLimit?: number | null
    usageCount?: number
    createdAt?: Date | string
    transactions?: WashTransactionUncheckedCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WashTransactionUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WashTransactionUncheckedUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeCreateManyInput = {
    id?: string
    code: string
    discount: number
    type: string
    expiry?: Date | string | null
    usageLimit?: number | null
    usageCount?: number
    createdAt?: Date | string
  }

  export type PromoCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    minStock?: number
    unit: string
    supplier?: string | null
    costPrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usages?: InventoryUsageCreateNestedManyWithoutItemInput
  }

  export type InventoryItemUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    minStock?: number
    unit: string
    supplier?: string | null
    costPrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usages?: InventoryUsageUncheckedCreateNestedManyWithoutItemInput
  }

  export type InventoryItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usages?: InventoryUsageUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usages?: InventoryUsageUncheckedUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    minStock?: number
    unit: string
    supplier?: string | null
    costPrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUsageCreateInput = {
    id?: string
    quantity: number
    reason: string
    transactionId?: string | null
    createdAt?: Date | string
    item: InventoryItemCreateNestedOneWithoutUsagesInput
  }

  export type InventoryUsageUncheckedCreateInput = {
    id?: string
    itemId: string
    quantity: number
    reason: string
    transactionId?: string | null
    createdAt?: Date | string
  }

  export type InventoryUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: InventoryItemUpdateOneRequiredWithoutUsagesNestedInput
  }

  export type InventoryUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUsageCreateManyInput = {
    id?: string
    itemId: string
    quantity: number
    reason: string
    transactionId?: string | null
    createdAt?: Date | string
  }

  export type InventoryUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffCreateInput = {
    id?: string
    name: string
    email: string
    role: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    shifts?: StaffShiftCreateNestedManyWithoutStaffInput
    audits?: AuditLogCreateNestedManyWithoutStaffInput
  }

  export type StaffUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    role: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    shifts?: StaffShiftUncheckedCreateNestedManyWithoutStaffInput
    audits?: AuditLogUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: StaffShiftUpdateManyWithoutStaffNestedInput
    audits?: AuditLogUpdateManyWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: StaffShiftUncheckedUpdateManyWithoutStaffNestedInput
    audits?: AuditLogUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type StaffCreateManyInput = {
    id?: string
    name: string
    email: string
    role: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type StaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffShiftCreateInput = {
    id?: string
    startTime: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    staff: StaffCreateNestedOneWithoutShiftsInput
  }

  export type StaffShiftUncheckedCreateInput = {
    id?: string
    staffId: string
    startTime: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
  }

  export type StaffShiftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneRequiredWithoutShiftsNestedInput
  }

  export type StaffShiftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffShiftCreateManyInput = {
    id?: string
    staffId: string
    startTime: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
  }

  export type StaffShiftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffShiftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    staff: StaffCreateNestedOneWithoutAuditsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    staffId: string
    action: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneRequiredWithoutAuditsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    staffId: string
    action: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessSettingsCreateInput = {
    id?: string
    name: string
    logo?: string | null
    taxRate?: number
    currency?: string
    receiptFooter?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessSettingsUncheckedCreateInput = {
    id?: string
    name: string
    logo?: string | null
    taxRate?: number
    currency?: string
    receiptFooter?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    receiptFooter?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    receiptFooter?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessSettingsCreateManyInput = {
    id?: string
    name: string
    logo?: string | null
    taxRate?: number
    currency?: string
    receiptFooter?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    receiptFooter?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    receiptFooter?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type WashTransactionListRelationFilter = {
    every?: WashTransactionWhereInput
    some?: WashTransactionWhereInput
    none?: WashTransactionWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type WashTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    loyaltyPoints?: SortOrder
    loyaltyTier?: SortOrder
    referralCode?: SortOrder
    referredBy?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    loyaltyPoints?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    loyaltyPoints?: SortOrder
    loyaltyTier?: SortOrder
    referralCode?: SortOrder
    referredBy?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    loyaltyPoints?: SortOrder
    loyaltyTier?: SortOrder
    referralCode?: SortOrder
    referredBy?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    loyaltyPoints?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type WashServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type WashServiceAvgOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type WashServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type WashServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
  }

  export type WashServiceSumOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type WashServiceScalarRelationFilter = {
    is?: WashServiceWhereInput
    isNot?: WashServiceWhereInput
  }

  export type PromoCodeNullableScalarRelationFilter = {
    is?: PromoCodeWhereInput | null
    isNot?: PromoCodeWhereInput | null
  }

  export type WashTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    vehicleType?: SortOrder
    discount?: SortOrder
    promoCodeId?: SortOrder
    receiptNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type WashTransactionAvgOrderByAggregateInput = {
    quantity?: SortOrder
    total?: SortOrder
    discount?: SortOrder
  }

  export type WashTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    vehicleType?: SortOrder
    discount?: SortOrder
    promoCodeId?: SortOrder
    receiptNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type WashTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    customerId?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    paymentMethod?: SortOrder
    vehicleType?: SortOrder
    discount?: SortOrder
    promoCodeId?: SortOrder
    receiptNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type WashTransactionSumOrderByAggregateInput = {
    quantity?: SortOrder
    total?: SortOrder
    discount?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PromoCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    discount?: SortOrder
    type?: SortOrder
    expiry?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
  }

  export type PromoCodeAvgOrderByAggregateInput = {
    discount?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
  }

  export type PromoCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    discount?: SortOrder
    type?: SortOrder
    expiry?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
  }

  export type PromoCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    discount?: SortOrder
    type?: SortOrder
    expiry?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
  }

  export type PromoCodeSumOrderByAggregateInput = {
    discount?: SortOrder
    usageLimit?: SortOrder
    usageCount?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type InventoryUsageListRelationFilter = {
    every?: InventoryUsageWhereInput
    some?: InventoryUsageWhereInput
    none?: InventoryUsageWhereInput
  }

  export type InventoryUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    minStock?: SortOrder
    unit?: SortOrder
    supplier?: SortOrder
    costPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    minStock?: SortOrder
    costPrice?: SortOrder
  }

  export type InventoryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    minStock?: SortOrder
    unit?: SortOrder
    supplier?: SortOrder
    costPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    minStock?: SortOrder
    unit?: SortOrder
    supplier?: SortOrder
    costPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    minStock?: SortOrder
    costPrice?: SortOrder
  }

  export type InventoryItemScalarRelationFilter = {
    is?: InventoryItemWhereInput
    isNot?: InventoryItemWhereInput
  }

  export type InventoryUsageCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryUsageAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type InventoryUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryUsageMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
  }

  export type InventoryUsageSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StaffShiftListRelationFilter = {
    every?: StaffShiftWhereInput
    some?: StaffShiftWhereInput
    none?: StaffShiftWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type StaffShiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type StaffMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type StaffMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StaffScalarRelationFilter = {
    is?: StaffWhereInput
    isNot?: StaffWhereInput
  }

  export type StaffShiftCountOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
  }

  export type StaffShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
  }

  export type StaffShiftMinOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type BusinessSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    taxRate?: SortOrder
    currency?: SortOrder
    receiptFooter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessSettingsAvgOrderByAggregateInput = {
    taxRate?: SortOrder
  }

  export type BusinessSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    taxRate?: SortOrder
    currency?: SortOrder
    receiptFooter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    taxRate?: SortOrder
    currency?: SortOrder
    receiptFooter?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessSettingsSumOrderByAggregateInput = {
    taxRate?: SortOrder
  }

  export type WashTransactionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<WashTransactionCreateWithoutCustomerInput, WashTransactionUncheckedCreateWithoutCustomerInput> | WashTransactionCreateWithoutCustomerInput[] | WashTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: WashTransactionCreateOrConnectWithoutCustomerInput | WashTransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: WashTransactionCreateManyCustomerInputEnvelope
    connect?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutReferrerInput = {
    create?: XOR<CustomerCreateWithoutReferrerInput, CustomerUncheckedCreateWithoutReferrerInput> | CustomerCreateWithoutReferrerInput[] | CustomerUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutReferrerInput | CustomerCreateOrConnectWithoutReferrerInput[]
    createMany?: CustomerCreateManyReferrerInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type CustomerCreateNestedOneWithoutReferralsInput = {
    create?: XOR<CustomerCreateWithoutReferralsInput, CustomerUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutReferralsInput
    connect?: CustomerWhereUniqueInput
  }

  export type WashTransactionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<WashTransactionCreateWithoutCustomerInput, WashTransactionUncheckedCreateWithoutCustomerInput> | WashTransactionCreateWithoutCustomerInput[] | WashTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: WashTransactionCreateOrConnectWithoutCustomerInput | WashTransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: WashTransactionCreateManyCustomerInputEnvelope
    connect?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutReferrerInput = {
    create?: XOR<CustomerCreateWithoutReferrerInput, CustomerUncheckedCreateWithoutReferrerInput> | CustomerCreateWithoutReferrerInput[] | CustomerUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutReferrerInput | CustomerCreateOrConnectWithoutReferrerInput[]
    createMany?: CustomerCreateManyReferrerInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type WashTransactionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<WashTransactionCreateWithoutCustomerInput, WashTransactionUncheckedCreateWithoutCustomerInput> | WashTransactionCreateWithoutCustomerInput[] | WashTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: WashTransactionCreateOrConnectWithoutCustomerInput | WashTransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: WashTransactionUpsertWithWhereUniqueWithoutCustomerInput | WashTransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: WashTransactionCreateManyCustomerInputEnvelope
    set?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    disconnect?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    delete?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    connect?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    update?: WashTransactionUpdateWithWhereUniqueWithoutCustomerInput | WashTransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: WashTransactionUpdateManyWithWhereWithoutCustomerInput | WashTransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: WashTransactionScalarWhereInput | WashTransactionScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<CustomerCreateWithoutReferrerInput, CustomerUncheckedCreateWithoutReferrerInput> | CustomerCreateWithoutReferrerInput[] | CustomerUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutReferrerInput | CustomerCreateOrConnectWithoutReferrerInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutReferrerInput | CustomerUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: CustomerCreateManyReferrerInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutReferrerInput | CustomerUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutReferrerInput | CustomerUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type CustomerUpdateOneWithoutReferralsNestedInput = {
    create?: XOR<CustomerCreateWithoutReferralsInput, CustomerUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutReferralsInput
    upsert?: CustomerUpsertWithoutReferralsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutReferralsInput, CustomerUpdateWithoutReferralsInput>, CustomerUncheckedUpdateWithoutReferralsInput>
  }

  export type WashTransactionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<WashTransactionCreateWithoutCustomerInput, WashTransactionUncheckedCreateWithoutCustomerInput> | WashTransactionCreateWithoutCustomerInput[] | WashTransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: WashTransactionCreateOrConnectWithoutCustomerInput | WashTransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: WashTransactionUpsertWithWhereUniqueWithoutCustomerInput | WashTransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: WashTransactionCreateManyCustomerInputEnvelope
    set?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    disconnect?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    delete?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    connect?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    update?: WashTransactionUpdateWithWhereUniqueWithoutCustomerInput | WashTransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: WashTransactionUpdateManyWithWhereWithoutCustomerInput | WashTransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: WashTransactionScalarWhereInput | WashTransactionScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<CustomerCreateWithoutReferrerInput, CustomerUncheckedCreateWithoutReferrerInput> | CustomerCreateWithoutReferrerInput[] | CustomerUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutReferrerInput | CustomerCreateOrConnectWithoutReferrerInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutReferrerInput | CustomerUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: CustomerCreateManyReferrerInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutReferrerInput | CustomerUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutReferrerInput | CustomerUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type WashTransactionCreateNestedManyWithoutServiceInput = {
    create?: XOR<WashTransactionCreateWithoutServiceInput, WashTransactionUncheckedCreateWithoutServiceInput> | WashTransactionCreateWithoutServiceInput[] | WashTransactionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: WashTransactionCreateOrConnectWithoutServiceInput | WashTransactionCreateOrConnectWithoutServiceInput[]
    createMany?: WashTransactionCreateManyServiceInputEnvelope
    connect?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
  }

  export type WashTransactionUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<WashTransactionCreateWithoutServiceInput, WashTransactionUncheckedCreateWithoutServiceInput> | WashTransactionCreateWithoutServiceInput[] | WashTransactionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: WashTransactionCreateOrConnectWithoutServiceInput | WashTransactionCreateOrConnectWithoutServiceInput[]
    createMany?: WashTransactionCreateManyServiceInputEnvelope
    connect?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WashTransactionUpdateManyWithoutServiceNestedInput = {
    create?: XOR<WashTransactionCreateWithoutServiceInput, WashTransactionUncheckedCreateWithoutServiceInput> | WashTransactionCreateWithoutServiceInput[] | WashTransactionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: WashTransactionCreateOrConnectWithoutServiceInput | WashTransactionCreateOrConnectWithoutServiceInput[]
    upsert?: WashTransactionUpsertWithWhereUniqueWithoutServiceInput | WashTransactionUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: WashTransactionCreateManyServiceInputEnvelope
    set?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    disconnect?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    delete?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    connect?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    update?: WashTransactionUpdateWithWhereUniqueWithoutServiceInput | WashTransactionUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: WashTransactionUpdateManyWithWhereWithoutServiceInput | WashTransactionUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: WashTransactionScalarWhereInput | WashTransactionScalarWhereInput[]
  }

  export type WashTransactionUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<WashTransactionCreateWithoutServiceInput, WashTransactionUncheckedCreateWithoutServiceInput> | WashTransactionCreateWithoutServiceInput[] | WashTransactionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: WashTransactionCreateOrConnectWithoutServiceInput | WashTransactionCreateOrConnectWithoutServiceInput[]
    upsert?: WashTransactionUpsertWithWhereUniqueWithoutServiceInput | WashTransactionUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: WashTransactionCreateManyServiceInputEnvelope
    set?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    disconnect?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    delete?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    connect?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    update?: WashTransactionUpdateWithWhereUniqueWithoutServiceInput | WashTransactionUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: WashTransactionUpdateManyWithWhereWithoutServiceInput | WashTransactionUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: WashTransactionScalarWhereInput | WashTransactionScalarWhereInput[]
  }

  export type WashServiceCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<WashServiceCreateWithoutTransactionsInput, WashServiceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: WashServiceCreateOrConnectWithoutTransactionsInput
    connect?: WashServiceWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTransactionsInput
    connect?: CustomerWhereUniqueInput
  }

  export type PromoCodeCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<PromoCodeCreateWithoutTransactionsInput, PromoCodeUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: PromoCodeCreateOrConnectWithoutTransactionsInput
    connect?: PromoCodeWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WashServiceUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<WashServiceCreateWithoutTransactionsInput, WashServiceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: WashServiceCreateOrConnectWithoutTransactionsInput
    upsert?: WashServiceUpsertWithoutTransactionsInput
    connect?: WashServiceWhereUniqueInput
    update?: XOR<XOR<WashServiceUpdateToOneWithWhereWithoutTransactionsInput, WashServiceUpdateWithoutTransactionsInput>, WashServiceUncheckedUpdateWithoutTransactionsInput>
  }

  export type CustomerUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTransactionsInput
    upsert?: CustomerUpsertWithoutTransactionsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutTransactionsInput, CustomerUpdateWithoutTransactionsInput>, CustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type PromoCodeUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<PromoCodeCreateWithoutTransactionsInput, PromoCodeUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: PromoCodeCreateOrConnectWithoutTransactionsInput
    upsert?: PromoCodeUpsertWithoutTransactionsInput
    disconnect?: PromoCodeWhereInput | boolean
    delete?: PromoCodeWhereInput | boolean
    connect?: PromoCodeWhereUniqueInput
    update?: XOR<XOR<PromoCodeUpdateToOneWithWhereWithoutTransactionsInput, PromoCodeUpdateWithoutTransactionsInput>, PromoCodeUncheckedUpdateWithoutTransactionsInput>
  }

  export type WashTransactionCreateNestedManyWithoutPromoCodeInput = {
    create?: XOR<WashTransactionCreateWithoutPromoCodeInput, WashTransactionUncheckedCreateWithoutPromoCodeInput> | WashTransactionCreateWithoutPromoCodeInput[] | WashTransactionUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: WashTransactionCreateOrConnectWithoutPromoCodeInput | WashTransactionCreateOrConnectWithoutPromoCodeInput[]
    createMany?: WashTransactionCreateManyPromoCodeInputEnvelope
    connect?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
  }

  export type WashTransactionUncheckedCreateNestedManyWithoutPromoCodeInput = {
    create?: XOR<WashTransactionCreateWithoutPromoCodeInput, WashTransactionUncheckedCreateWithoutPromoCodeInput> | WashTransactionCreateWithoutPromoCodeInput[] | WashTransactionUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: WashTransactionCreateOrConnectWithoutPromoCodeInput | WashTransactionCreateOrConnectWithoutPromoCodeInput[]
    createMany?: WashTransactionCreateManyPromoCodeInputEnvelope
    connect?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WashTransactionUpdateManyWithoutPromoCodeNestedInput = {
    create?: XOR<WashTransactionCreateWithoutPromoCodeInput, WashTransactionUncheckedCreateWithoutPromoCodeInput> | WashTransactionCreateWithoutPromoCodeInput[] | WashTransactionUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: WashTransactionCreateOrConnectWithoutPromoCodeInput | WashTransactionCreateOrConnectWithoutPromoCodeInput[]
    upsert?: WashTransactionUpsertWithWhereUniqueWithoutPromoCodeInput | WashTransactionUpsertWithWhereUniqueWithoutPromoCodeInput[]
    createMany?: WashTransactionCreateManyPromoCodeInputEnvelope
    set?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    disconnect?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    delete?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    connect?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    update?: WashTransactionUpdateWithWhereUniqueWithoutPromoCodeInput | WashTransactionUpdateWithWhereUniqueWithoutPromoCodeInput[]
    updateMany?: WashTransactionUpdateManyWithWhereWithoutPromoCodeInput | WashTransactionUpdateManyWithWhereWithoutPromoCodeInput[]
    deleteMany?: WashTransactionScalarWhereInput | WashTransactionScalarWhereInput[]
  }

  export type WashTransactionUncheckedUpdateManyWithoutPromoCodeNestedInput = {
    create?: XOR<WashTransactionCreateWithoutPromoCodeInput, WashTransactionUncheckedCreateWithoutPromoCodeInput> | WashTransactionCreateWithoutPromoCodeInput[] | WashTransactionUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: WashTransactionCreateOrConnectWithoutPromoCodeInput | WashTransactionCreateOrConnectWithoutPromoCodeInput[]
    upsert?: WashTransactionUpsertWithWhereUniqueWithoutPromoCodeInput | WashTransactionUpsertWithWhereUniqueWithoutPromoCodeInput[]
    createMany?: WashTransactionCreateManyPromoCodeInputEnvelope
    set?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    disconnect?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    delete?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    connect?: WashTransactionWhereUniqueInput | WashTransactionWhereUniqueInput[]
    update?: WashTransactionUpdateWithWhereUniqueWithoutPromoCodeInput | WashTransactionUpdateWithWhereUniqueWithoutPromoCodeInput[]
    updateMany?: WashTransactionUpdateManyWithWhereWithoutPromoCodeInput | WashTransactionUpdateManyWithWhereWithoutPromoCodeInput[]
    deleteMany?: WashTransactionScalarWhereInput | WashTransactionScalarWhereInput[]
  }

  export type InventoryUsageCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryUsageCreateWithoutItemInput, InventoryUsageUncheckedCreateWithoutItemInput> | InventoryUsageCreateWithoutItemInput[] | InventoryUsageUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutItemInput | InventoryUsageCreateOrConnectWithoutItemInput[]
    createMany?: InventoryUsageCreateManyItemInputEnvelope
    connect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
  }

  export type InventoryUsageUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryUsageCreateWithoutItemInput, InventoryUsageUncheckedCreateWithoutItemInput> | InventoryUsageCreateWithoutItemInput[] | InventoryUsageUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutItemInput | InventoryUsageCreateOrConnectWithoutItemInput[]
    createMany?: InventoryUsageCreateManyItemInputEnvelope
    connect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
  }

  export type InventoryUsageUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryUsageCreateWithoutItemInput, InventoryUsageUncheckedCreateWithoutItemInput> | InventoryUsageCreateWithoutItemInput[] | InventoryUsageUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutItemInput | InventoryUsageCreateOrConnectWithoutItemInput[]
    upsert?: InventoryUsageUpsertWithWhereUniqueWithoutItemInput | InventoryUsageUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryUsageCreateManyItemInputEnvelope
    set?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    disconnect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    delete?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    connect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    update?: InventoryUsageUpdateWithWhereUniqueWithoutItemInput | InventoryUsageUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryUsageUpdateManyWithWhereWithoutItemInput | InventoryUsageUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryUsageScalarWhereInput | InventoryUsageScalarWhereInput[]
  }

  export type InventoryUsageUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryUsageCreateWithoutItemInput, InventoryUsageUncheckedCreateWithoutItemInput> | InventoryUsageCreateWithoutItemInput[] | InventoryUsageUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryUsageCreateOrConnectWithoutItemInput | InventoryUsageCreateOrConnectWithoutItemInput[]
    upsert?: InventoryUsageUpsertWithWhereUniqueWithoutItemInput | InventoryUsageUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryUsageCreateManyItemInputEnvelope
    set?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    disconnect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    delete?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    connect?: InventoryUsageWhereUniqueInput | InventoryUsageWhereUniqueInput[]
    update?: InventoryUsageUpdateWithWhereUniqueWithoutItemInput | InventoryUsageUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryUsageUpdateManyWithWhereWithoutItemInput | InventoryUsageUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryUsageScalarWhereInput | InventoryUsageScalarWhereInput[]
  }

  export type InventoryItemCreateNestedOneWithoutUsagesInput = {
    create?: XOR<InventoryItemCreateWithoutUsagesInput, InventoryItemUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutUsagesInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type InventoryItemUpdateOneRequiredWithoutUsagesNestedInput = {
    create?: XOR<InventoryItemCreateWithoutUsagesInput, InventoryItemUncheckedCreateWithoutUsagesInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutUsagesInput
    upsert?: InventoryItemUpsertWithoutUsagesInput
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutUsagesInput, InventoryItemUpdateWithoutUsagesInput>, InventoryItemUncheckedUpdateWithoutUsagesInput>
  }

  export type StaffShiftCreateNestedManyWithoutStaffInput = {
    create?: XOR<StaffShiftCreateWithoutStaffInput, StaffShiftUncheckedCreateWithoutStaffInput> | StaffShiftCreateWithoutStaffInput[] | StaffShiftUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: StaffShiftCreateOrConnectWithoutStaffInput | StaffShiftCreateOrConnectWithoutStaffInput[]
    createMany?: StaffShiftCreateManyStaffInputEnvelope
    connect?: StaffShiftWhereUniqueInput | StaffShiftWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutStaffInput = {
    create?: XOR<AuditLogCreateWithoutStaffInput, AuditLogUncheckedCreateWithoutStaffInput> | AuditLogCreateWithoutStaffInput[] | AuditLogUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutStaffInput | AuditLogCreateOrConnectWithoutStaffInput[]
    createMany?: AuditLogCreateManyStaffInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StaffShiftUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<StaffShiftCreateWithoutStaffInput, StaffShiftUncheckedCreateWithoutStaffInput> | StaffShiftCreateWithoutStaffInput[] | StaffShiftUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: StaffShiftCreateOrConnectWithoutStaffInput | StaffShiftCreateOrConnectWithoutStaffInput[]
    createMany?: StaffShiftCreateManyStaffInputEnvelope
    connect?: StaffShiftWhereUniqueInput | StaffShiftWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<AuditLogCreateWithoutStaffInput, AuditLogUncheckedCreateWithoutStaffInput> | AuditLogCreateWithoutStaffInput[] | AuditLogUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutStaffInput | AuditLogCreateOrConnectWithoutStaffInput[]
    createMany?: AuditLogCreateManyStaffInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type StaffShiftUpdateManyWithoutStaffNestedInput = {
    create?: XOR<StaffShiftCreateWithoutStaffInput, StaffShiftUncheckedCreateWithoutStaffInput> | StaffShiftCreateWithoutStaffInput[] | StaffShiftUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: StaffShiftCreateOrConnectWithoutStaffInput | StaffShiftCreateOrConnectWithoutStaffInput[]
    upsert?: StaffShiftUpsertWithWhereUniqueWithoutStaffInput | StaffShiftUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: StaffShiftCreateManyStaffInputEnvelope
    set?: StaffShiftWhereUniqueInput | StaffShiftWhereUniqueInput[]
    disconnect?: StaffShiftWhereUniqueInput | StaffShiftWhereUniqueInput[]
    delete?: StaffShiftWhereUniqueInput | StaffShiftWhereUniqueInput[]
    connect?: StaffShiftWhereUniqueInput | StaffShiftWhereUniqueInput[]
    update?: StaffShiftUpdateWithWhereUniqueWithoutStaffInput | StaffShiftUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: StaffShiftUpdateManyWithWhereWithoutStaffInput | StaffShiftUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: StaffShiftScalarWhereInput | StaffShiftScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutStaffNestedInput = {
    create?: XOR<AuditLogCreateWithoutStaffInput, AuditLogUncheckedCreateWithoutStaffInput> | AuditLogCreateWithoutStaffInput[] | AuditLogUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutStaffInput | AuditLogCreateOrConnectWithoutStaffInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutStaffInput | AuditLogUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: AuditLogCreateManyStaffInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutStaffInput | AuditLogUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutStaffInput | AuditLogUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type StaffShiftUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<StaffShiftCreateWithoutStaffInput, StaffShiftUncheckedCreateWithoutStaffInput> | StaffShiftCreateWithoutStaffInput[] | StaffShiftUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: StaffShiftCreateOrConnectWithoutStaffInput | StaffShiftCreateOrConnectWithoutStaffInput[]
    upsert?: StaffShiftUpsertWithWhereUniqueWithoutStaffInput | StaffShiftUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: StaffShiftCreateManyStaffInputEnvelope
    set?: StaffShiftWhereUniqueInput | StaffShiftWhereUniqueInput[]
    disconnect?: StaffShiftWhereUniqueInput | StaffShiftWhereUniqueInput[]
    delete?: StaffShiftWhereUniqueInput | StaffShiftWhereUniqueInput[]
    connect?: StaffShiftWhereUniqueInput | StaffShiftWhereUniqueInput[]
    update?: StaffShiftUpdateWithWhereUniqueWithoutStaffInput | StaffShiftUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: StaffShiftUpdateManyWithWhereWithoutStaffInput | StaffShiftUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: StaffShiftScalarWhereInput | StaffShiftScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<AuditLogCreateWithoutStaffInput, AuditLogUncheckedCreateWithoutStaffInput> | AuditLogCreateWithoutStaffInput[] | AuditLogUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutStaffInput | AuditLogCreateOrConnectWithoutStaffInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutStaffInput | AuditLogUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: AuditLogCreateManyStaffInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutStaffInput | AuditLogUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutStaffInput | AuditLogUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type StaffCreateNestedOneWithoutShiftsInput = {
    create?: XOR<StaffCreateWithoutShiftsInput, StaffUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutShiftsInput
    connect?: StaffWhereUniqueInput
  }

  export type StaffUpdateOneRequiredWithoutShiftsNestedInput = {
    create?: XOR<StaffCreateWithoutShiftsInput, StaffUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutShiftsInput
    upsert?: StaffUpsertWithoutShiftsInput
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutShiftsInput, StaffUpdateWithoutShiftsInput>, StaffUncheckedUpdateWithoutShiftsInput>
  }

  export type StaffCreateNestedOneWithoutAuditsInput = {
    create?: XOR<StaffCreateWithoutAuditsInput, StaffUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutAuditsInput
    connect?: StaffWhereUniqueInput
  }

  export type StaffUpdateOneRequiredWithoutAuditsNestedInput = {
    create?: XOR<StaffCreateWithoutAuditsInput, StaffUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutAuditsInput
    upsert?: StaffUpsertWithoutAuditsInput
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutAuditsInput, StaffUpdateWithoutAuditsInput>, StaffUncheckedUpdateWithoutAuditsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type WashTransactionCreateWithoutCustomerInput = {
    id?: string
    quantity: number
    total: number
    paymentMethod?: string | null
    vehicleType?: string | null
    discount?: number | null
    receiptNumber?: string | null
    createdAt?: Date | string
    service: WashServiceCreateNestedOneWithoutTransactionsInput
    promoCode?: PromoCodeCreateNestedOneWithoutTransactionsInput
  }

  export type WashTransactionUncheckedCreateWithoutCustomerInput = {
    id?: string
    serviceId: string
    quantity: number
    total: number
    paymentMethod?: string | null
    vehicleType?: string | null
    discount?: number | null
    promoCodeId?: string | null
    receiptNumber?: string | null
    createdAt?: Date | string
  }

  export type WashTransactionCreateOrConnectWithoutCustomerInput = {
    where: WashTransactionWhereUniqueInput
    create: XOR<WashTransactionCreateWithoutCustomerInput, WashTransactionUncheckedCreateWithoutCustomerInput>
  }

  export type WashTransactionCreateManyCustomerInputEnvelope = {
    data: WashTransactionCreateManyCustomerInput | WashTransactionCreateManyCustomerInput[]
  }

  export type CustomerCreateWithoutReferrerInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    loyaltyPoints?: number
    loyaltyTier?: string
    referralCode?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    transactions?: WashTransactionCreateNestedManyWithoutCustomerInput
    referrals?: CustomerCreateNestedManyWithoutReferrerInput
  }

  export type CustomerUncheckedCreateWithoutReferrerInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    loyaltyPoints?: number
    loyaltyTier?: string
    referralCode?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    transactions?: WashTransactionUncheckedCreateNestedManyWithoutCustomerInput
    referrals?: CustomerUncheckedCreateNestedManyWithoutReferrerInput
  }

  export type CustomerCreateOrConnectWithoutReferrerInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutReferrerInput, CustomerUncheckedCreateWithoutReferrerInput>
  }

  export type CustomerCreateManyReferrerInputEnvelope = {
    data: CustomerCreateManyReferrerInput | CustomerCreateManyReferrerInput[]
  }

  export type CustomerCreateWithoutReferralsInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    loyaltyPoints?: number
    loyaltyTier?: string
    referralCode?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    transactions?: WashTransactionCreateNestedManyWithoutCustomerInput
    referrer?: CustomerCreateNestedOneWithoutReferralsInput
  }

  export type CustomerUncheckedCreateWithoutReferralsInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    loyaltyPoints?: number
    loyaltyTier?: string
    referralCode?: string | null
    referredBy?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    transactions?: WashTransactionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutReferralsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutReferralsInput, CustomerUncheckedCreateWithoutReferralsInput>
  }

  export type WashTransactionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: WashTransactionWhereUniqueInput
    update: XOR<WashTransactionUpdateWithoutCustomerInput, WashTransactionUncheckedUpdateWithoutCustomerInput>
    create: XOR<WashTransactionCreateWithoutCustomerInput, WashTransactionUncheckedCreateWithoutCustomerInput>
  }

  export type WashTransactionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: WashTransactionWhereUniqueInput
    data: XOR<WashTransactionUpdateWithoutCustomerInput, WashTransactionUncheckedUpdateWithoutCustomerInput>
  }

  export type WashTransactionUpdateManyWithWhereWithoutCustomerInput = {
    where: WashTransactionScalarWhereInput
    data: XOR<WashTransactionUpdateManyMutationInput, WashTransactionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type WashTransactionScalarWhereInput = {
    AND?: WashTransactionScalarWhereInput | WashTransactionScalarWhereInput[]
    OR?: WashTransactionScalarWhereInput[]
    NOT?: WashTransactionScalarWhereInput | WashTransactionScalarWhereInput[]
    id?: StringFilter<"WashTransaction"> | string
    serviceId?: StringFilter<"WashTransaction"> | string
    customerId?: StringNullableFilter<"WashTransaction"> | string | null
    quantity?: IntFilter<"WashTransaction"> | number
    total?: FloatFilter<"WashTransaction"> | number
    paymentMethod?: StringNullableFilter<"WashTransaction"> | string | null
    vehicleType?: StringNullableFilter<"WashTransaction"> | string | null
    discount?: FloatNullableFilter<"WashTransaction"> | number | null
    promoCodeId?: StringNullableFilter<"WashTransaction"> | string | null
    receiptNumber?: StringNullableFilter<"WashTransaction"> | string | null
    createdAt?: DateTimeFilter<"WashTransaction"> | Date | string
  }

  export type CustomerUpsertWithWhereUniqueWithoutReferrerInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutReferrerInput, CustomerUncheckedUpdateWithoutReferrerInput>
    create: XOR<CustomerCreateWithoutReferrerInput, CustomerUncheckedCreateWithoutReferrerInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutReferrerInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutReferrerInput, CustomerUncheckedUpdateWithoutReferrerInput>
  }

  export type CustomerUpdateManyWithWhereWithoutReferrerInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutReferrerInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    loyaltyPoints?: IntFilter<"Customer"> | number
    loyaltyTier?: StringFilter<"Customer"> | string
    referralCode?: StringNullableFilter<"Customer"> | string | null
    referredBy?: StringNullableFilter<"Customer"> | string | null
    preferences?: JsonNullableFilter<"Customer">
    createdAt?: DateTimeFilter<"Customer"> | Date | string
  }

  export type CustomerUpsertWithoutReferralsInput = {
    update: XOR<CustomerUpdateWithoutReferralsInput, CustomerUncheckedUpdateWithoutReferralsInput>
    create: XOR<CustomerCreateWithoutReferralsInput, CustomerUncheckedCreateWithoutReferralsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutReferralsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutReferralsInput, CustomerUncheckedUpdateWithoutReferralsInput>
  }

  export type CustomerUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WashTransactionUpdateManyWithoutCustomerNestedInput
    referrer?: CustomerUpdateOneWithoutReferralsNestedInput
  }

  export type CustomerUncheckedUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WashTransactionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type WashTransactionCreateWithoutServiceInput = {
    id?: string
    quantity: number
    total: number
    paymentMethod?: string | null
    vehicleType?: string | null
    discount?: number | null
    receiptNumber?: string | null
    createdAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
    promoCode?: PromoCodeCreateNestedOneWithoutTransactionsInput
  }

  export type WashTransactionUncheckedCreateWithoutServiceInput = {
    id?: string
    customerId?: string | null
    quantity: number
    total: number
    paymentMethod?: string | null
    vehicleType?: string | null
    discount?: number | null
    promoCodeId?: string | null
    receiptNumber?: string | null
    createdAt?: Date | string
  }

  export type WashTransactionCreateOrConnectWithoutServiceInput = {
    where: WashTransactionWhereUniqueInput
    create: XOR<WashTransactionCreateWithoutServiceInput, WashTransactionUncheckedCreateWithoutServiceInput>
  }

  export type WashTransactionCreateManyServiceInputEnvelope = {
    data: WashTransactionCreateManyServiceInput | WashTransactionCreateManyServiceInput[]
  }

  export type WashTransactionUpsertWithWhereUniqueWithoutServiceInput = {
    where: WashTransactionWhereUniqueInput
    update: XOR<WashTransactionUpdateWithoutServiceInput, WashTransactionUncheckedUpdateWithoutServiceInput>
    create: XOR<WashTransactionCreateWithoutServiceInput, WashTransactionUncheckedCreateWithoutServiceInput>
  }

  export type WashTransactionUpdateWithWhereUniqueWithoutServiceInput = {
    where: WashTransactionWhereUniqueInput
    data: XOR<WashTransactionUpdateWithoutServiceInput, WashTransactionUncheckedUpdateWithoutServiceInput>
  }

  export type WashTransactionUpdateManyWithWhereWithoutServiceInput = {
    where: WashTransactionScalarWhereInput
    data: XOR<WashTransactionUpdateManyMutationInput, WashTransactionUncheckedUpdateManyWithoutServiceInput>
  }

  export type WashServiceCreateWithoutTransactionsInput = {
    id?: string
    name: string
    price: number
    duration: number
    createdAt?: Date | string
  }

  export type WashServiceUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    price: number
    duration: number
    createdAt?: Date | string
  }

  export type WashServiceCreateOrConnectWithoutTransactionsInput = {
    where: WashServiceWhereUniqueInput
    create: XOR<WashServiceCreateWithoutTransactionsInput, WashServiceUncheckedCreateWithoutTransactionsInput>
  }

  export type CustomerCreateWithoutTransactionsInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    loyaltyPoints?: number
    loyaltyTier?: string
    referralCode?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    referrals?: CustomerCreateNestedManyWithoutReferrerInput
    referrer?: CustomerCreateNestedOneWithoutReferralsInput
  }

  export type CustomerUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    loyaltyPoints?: number
    loyaltyTier?: string
    referralCode?: string | null
    referredBy?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    referrals?: CustomerUncheckedCreateNestedManyWithoutReferrerInput
  }

  export type CustomerCreateOrConnectWithoutTransactionsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
  }

  export type PromoCodeCreateWithoutTransactionsInput = {
    id?: string
    code: string
    discount: number
    type: string
    expiry?: Date | string | null
    usageLimit?: number | null
    usageCount?: number
    createdAt?: Date | string
  }

  export type PromoCodeUncheckedCreateWithoutTransactionsInput = {
    id?: string
    code: string
    discount: number
    type: string
    expiry?: Date | string | null
    usageLimit?: number | null
    usageCount?: number
    createdAt?: Date | string
  }

  export type PromoCodeCreateOrConnectWithoutTransactionsInput = {
    where: PromoCodeWhereUniqueInput
    create: XOR<PromoCodeCreateWithoutTransactionsInput, PromoCodeUncheckedCreateWithoutTransactionsInput>
  }

  export type WashServiceUpsertWithoutTransactionsInput = {
    update: XOR<WashServiceUpdateWithoutTransactionsInput, WashServiceUncheckedUpdateWithoutTransactionsInput>
    create: XOR<WashServiceCreateWithoutTransactionsInput, WashServiceUncheckedCreateWithoutTransactionsInput>
    where?: WashServiceWhereInput
  }

  export type WashServiceUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: WashServiceWhereInput
    data: XOR<WashServiceUpdateWithoutTransactionsInput, WashServiceUncheckedUpdateWithoutTransactionsInput>
  }

  export type WashServiceUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashServiceUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUpsertWithoutTransactionsInput = {
    update: XOR<CustomerUpdateWithoutTransactionsInput, CustomerUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutTransactionsInput, CustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type CustomerUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrals?: CustomerUpdateManyWithoutReferrerNestedInput
    referrer?: CustomerUpdateOneWithoutReferralsNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrals?: CustomerUncheckedUpdateManyWithoutReferrerNestedInput
  }

  export type PromoCodeUpsertWithoutTransactionsInput = {
    update: XOR<PromoCodeUpdateWithoutTransactionsInput, PromoCodeUncheckedUpdateWithoutTransactionsInput>
    create: XOR<PromoCodeCreateWithoutTransactionsInput, PromoCodeUncheckedCreateWithoutTransactionsInput>
    where?: PromoCodeWhereInput
  }

  export type PromoCodeUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: PromoCodeWhereInput
    data: XOR<PromoCodeUpdateWithoutTransactionsInput, PromoCodeUncheckedUpdateWithoutTransactionsInput>
  }

  export type PromoCodeUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashTransactionCreateWithoutPromoCodeInput = {
    id?: string
    quantity: number
    total: number
    paymentMethod?: string | null
    vehicleType?: string | null
    discount?: number | null
    receiptNumber?: string | null
    createdAt?: Date | string
    service: WashServiceCreateNestedOneWithoutTransactionsInput
    customer?: CustomerCreateNestedOneWithoutTransactionsInput
  }

  export type WashTransactionUncheckedCreateWithoutPromoCodeInput = {
    id?: string
    serviceId: string
    customerId?: string | null
    quantity: number
    total: number
    paymentMethod?: string | null
    vehicleType?: string | null
    discount?: number | null
    receiptNumber?: string | null
    createdAt?: Date | string
  }

  export type WashTransactionCreateOrConnectWithoutPromoCodeInput = {
    where: WashTransactionWhereUniqueInput
    create: XOR<WashTransactionCreateWithoutPromoCodeInput, WashTransactionUncheckedCreateWithoutPromoCodeInput>
  }

  export type WashTransactionCreateManyPromoCodeInputEnvelope = {
    data: WashTransactionCreateManyPromoCodeInput | WashTransactionCreateManyPromoCodeInput[]
  }

  export type WashTransactionUpsertWithWhereUniqueWithoutPromoCodeInput = {
    where: WashTransactionWhereUniqueInput
    update: XOR<WashTransactionUpdateWithoutPromoCodeInput, WashTransactionUncheckedUpdateWithoutPromoCodeInput>
    create: XOR<WashTransactionCreateWithoutPromoCodeInput, WashTransactionUncheckedCreateWithoutPromoCodeInput>
  }

  export type WashTransactionUpdateWithWhereUniqueWithoutPromoCodeInput = {
    where: WashTransactionWhereUniqueInput
    data: XOR<WashTransactionUpdateWithoutPromoCodeInput, WashTransactionUncheckedUpdateWithoutPromoCodeInput>
  }

  export type WashTransactionUpdateManyWithWhereWithoutPromoCodeInput = {
    where: WashTransactionScalarWhereInput
    data: XOR<WashTransactionUpdateManyMutationInput, WashTransactionUncheckedUpdateManyWithoutPromoCodeInput>
  }

  export type InventoryUsageCreateWithoutItemInput = {
    id?: string
    quantity: number
    reason: string
    transactionId?: string | null
    createdAt?: Date | string
  }

  export type InventoryUsageUncheckedCreateWithoutItemInput = {
    id?: string
    quantity: number
    reason: string
    transactionId?: string | null
    createdAt?: Date | string
  }

  export type InventoryUsageCreateOrConnectWithoutItemInput = {
    where: InventoryUsageWhereUniqueInput
    create: XOR<InventoryUsageCreateWithoutItemInput, InventoryUsageUncheckedCreateWithoutItemInput>
  }

  export type InventoryUsageCreateManyItemInputEnvelope = {
    data: InventoryUsageCreateManyItemInput | InventoryUsageCreateManyItemInput[]
  }

  export type InventoryUsageUpsertWithWhereUniqueWithoutItemInput = {
    where: InventoryUsageWhereUniqueInput
    update: XOR<InventoryUsageUpdateWithoutItemInput, InventoryUsageUncheckedUpdateWithoutItemInput>
    create: XOR<InventoryUsageCreateWithoutItemInput, InventoryUsageUncheckedCreateWithoutItemInput>
  }

  export type InventoryUsageUpdateWithWhereUniqueWithoutItemInput = {
    where: InventoryUsageWhereUniqueInput
    data: XOR<InventoryUsageUpdateWithoutItemInput, InventoryUsageUncheckedUpdateWithoutItemInput>
  }

  export type InventoryUsageUpdateManyWithWhereWithoutItemInput = {
    where: InventoryUsageScalarWhereInput
    data: XOR<InventoryUsageUpdateManyMutationInput, InventoryUsageUncheckedUpdateManyWithoutItemInput>
  }

  export type InventoryUsageScalarWhereInput = {
    AND?: InventoryUsageScalarWhereInput | InventoryUsageScalarWhereInput[]
    OR?: InventoryUsageScalarWhereInput[]
    NOT?: InventoryUsageScalarWhereInput | InventoryUsageScalarWhereInput[]
    id?: StringFilter<"InventoryUsage"> | string
    itemId?: StringFilter<"InventoryUsage"> | string
    quantity?: IntFilter<"InventoryUsage"> | number
    reason?: StringFilter<"InventoryUsage"> | string
    transactionId?: StringNullableFilter<"InventoryUsage"> | string | null
    createdAt?: DateTimeFilter<"InventoryUsage"> | Date | string
  }

  export type InventoryItemCreateWithoutUsagesInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    minStock?: number
    unit: string
    supplier?: string | null
    costPrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemUncheckedCreateWithoutUsagesInput = {
    id?: string
    name: string
    description?: string | null
    quantity: number
    minStock?: number
    unit: string
    supplier?: string | null
    costPrice?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemCreateOrConnectWithoutUsagesInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutUsagesInput, InventoryItemUncheckedCreateWithoutUsagesInput>
  }

  export type InventoryItemUpsertWithoutUsagesInput = {
    update: XOR<InventoryItemUpdateWithoutUsagesInput, InventoryItemUncheckedUpdateWithoutUsagesInput>
    create: XOR<InventoryItemCreateWithoutUsagesInput, InventoryItemUncheckedCreateWithoutUsagesInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutUsagesInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutUsagesInput, InventoryItemUncheckedUpdateWithoutUsagesInput>
  }

  export type InventoryItemUpdateWithoutUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateWithoutUsagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffShiftCreateWithoutStaffInput = {
    id?: string
    startTime: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
  }

  export type StaffShiftUncheckedCreateWithoutStaffInput = {
    id?: string
    startTime: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
  }

  export type StaffShiftCreateOrConnectWithoutStaffInput = {
    where: StaffShiftWhereUniqueInput
    create: XOR<StaffShiftCreateWithoutStaffInput, StaffShiftUncheckedCreateWithoutStaffInput>
  }

  export type StaffShiftCreateManyStaffInputEnvelope = {
    data: StaffShiftCreateManyStaffInput | StaffShiftCreateManyStaffInput[]
  }

  export type AuditLogCreateWithoutStaffInput = {
    id?: string
    action: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutStaffInput = {
    id?: string
    action: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutStaffInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutStaffInput, AuditLogUncheckedCreateWithoutStaffInput>
  }

  export type AuditLogCreateManyStaffInputEnvelope = {
    data: AuditLogCreateManyStaffInput | AuditLogCreateManyStaffInput[]
  }

  export type StaffShiftUpsertWithWhereUniqueWithoutStaffInput = {
    where: StaffShiftWhereUniqueInput
    update: XOR<StaffShiftUpdateWithoutStaffInput, StaffShiftUncheckedUpdateWithoutStaffInput>
    create: XOR<StaffShiftCreateWithoutStaffInput, StaffShiftUncheckedCreateWithoutStaffInput>
  }

  export type StaffShiftUpdateWithWhereUniqueWithoutStaffInput = {
    where: StaffShiftWhereUniqueInput
    data: XOR<StaffShiftUpdateWithoutStaffInput, StaffShiftUncheckedUpdateWithoutStaffInput>
  }

  export type StaffShiftUpdateManyWithWhereWithoutStaffInput = {
    where: StaffShiftScalarWhereInput
    data: XOR<StaffShiftUpdateManyMutationInput, StaffShiftUncheckedUpdateManyWithoutStaffInput>
  }

  export type StaffShiftScalarWhereInput = {
    AND?: StaffShiftScalarWhereInput | StaffShiftScalarWhereInput[]
    OR?: StaffShiftScalarWhereInput[]
    NOT?: StaffShiftScalarWhereInput | StaffShiftScalarWhereInput[]
    id?: StringFilter<"StaffShift"> | string
    staffId?: StringFilter<"StaffShift"> | string
    startTime?: DateTimeFilter<"StaffShift"> | Date | string
    endTime?: DateTimeNullableFilter<"StaffShift"> | Date | string | null
    createdAt?: DateTimeFilter<"StaffShift"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutStaffInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutStaffInput, AuditLogUncheckedUpdateWithoutStaffInput>
    create: XOR<AuditLogCreateWithoutStaffInput, AuditLogUncheckedCreateWithoutStaffInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutStaffInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutStaffInput, AuditLogUncheckedUpdateWithoutStaffInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutStaffInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutStaffInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    staffId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    details?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type StaffCreateWithoutShiftsInput = {
    id?: string
    name: string
    email: string
    role: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    audits?: AuditLogCreateNestedManyWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutShiftsInput = {
    id?: string
    name: string
    email: string
    role: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    audits?: AuditLogUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutShiftsInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutShiftsInput, StaffUncheckedCreateWithoutShiftsInput>
  }

  export type StaffUpsertWithoutShiftsInput = {
    update: XOR<StaffUpdateWithoutShiftsInput, StaffUncheckedUpdateWithoutShiftsInput>
    create: XOR<StaffCreateWithoutShiftsInput, StaffUncheckedCreateWithoutShiftsInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutShiftsInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutShiftsInput, StaffUncheckedUpdateWithoutShiftsInput>
  }

  export type StaffUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditLogUpdateManyWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AuditLogUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type StaffCreateWithoutAuditsInput = {
    id?: string
    name: string
    email: string
    role: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    shifts?: StaffShiftCreateNestedManyWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutAuditsInput = {
    id?: string
    name: string
    email: string
    role: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    shifts?: StaffShiftUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutAuditsInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutAuditsInput, StaffUncheckedCreateWithoutAuditsInput>
  }

  export type StaffUpsertWithoutAuditsInput = {
    update: XOR<StaffUpdateWithoutAuditsInput, StaffUncheckedUpdateWithoutAuditsInput>
    create: XOR<StaffCreateWithoutAuditsInput, StaffUncheckedCreateWithoutAuditsInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutAuditsInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutAuditsInput, StaffUncheckedUpdateWithoutAuditsInput>
  }

  export type StaffUpdateWithoutAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: StaffShiftUpdateManyWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: StaffShiftUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type WashTransactionCreateManyCustomerInput = {
    id?: string
    serviceId: string
    quantity: number
    total: number
    paymentMethod?: string | null
    vehicleType?: string | null
    discount?: number | null
    promoCodeId?: string | null
    receiptNumber?: string | null
    createdAt?: Date | string
  }

  export type CustomerCreateManyReferrerInput = {
    id?: string
    name: string
    phone?: string | null
    email?: string | null
    loyaltyPoints?: number
    loyaltyTier?: string
    referralCode?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type WashTransactionUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: WashServiceUpdateOneRequiredWithoutTransactionsNestedInput
    promoCode?: PromoCodeUpdateOneWithoutTransactionsNestedInput
  }

  export type WashTransactionUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashTransactionUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WashTransactionUpdateManyWithoutCustomerNestedInput
    referrals?: CustomerUpdateManyWithoutReferrerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WashTransactionUncheckedUpdateManyWithoutCustomerNestedInput
    referrals?: CustomerUncheckedUpdateManyWithoutReferrerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    loyaltyTier?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashTransactionCreateManyServiceInput = {
    id?: string
    customerId?: string | null
    quantity: number
    total: number
    paymentMethod?: string | null
    vehicleType?: string | null
    discount?: number | null
    promoCodeId?: string | null
    receiptNumber?: string | null
    createdAt?: Date | string
  }

  export type WashTransactionUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
    promoCode?: PromoCodeUpdateOneWithoutTransactionsNestedInput
  }

  export type WashTransactionUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashTransactionUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashTransactionCreateManyPromoCodeInput = {
    id?: string
    serviceId: string
    customerId?: string | null
    quantity: number
    total: number
    paymentMethod?: string | null
    vehicleType?: string | null
    discount?: number | null
    receiptNumber?: string | null
    createdAt?: Date | string
  }

  export type WashTransactionUpdateWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: WashServiceUpdateOneRequiredWithoutTransactionsNestedInput
    customer?: CustomerUpdateOneWithoutTransactionsNestedInput
  }

  export type WashTransactionUncheckedUpdateWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WashTransactionUncheckedUpdateManyWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleType?: NullableStringFieldUpdateOperationsInput | string | null
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUsageCreateManyItemInput = {
    id?: string
    quantity: number
    reason: string
    transactionId?: string | null
    createdAt?: Date | string
  }

  export type InventoryUsageUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUsageUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUsageUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffShiftCreateManyStaffInput = {
    id?: string
    startTime: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateManyStaffInput = {
    id?: string
    action: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type StaffShiftUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffShiftUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffShiftUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}